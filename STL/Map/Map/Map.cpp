#include <iostream>
using namespace std;
#include <vector>
#include <list>
#include <deque>
#include <map>

// Map

class Player
{
public:
	Player() : _playerId(0)
	{

	}
	Player(int playerid) : _playerId(playerid)
	{

	}

public:
	int _playerId;

};

//template<typename T1, typename T2>
//struct Pair
//{
//	T1 t1;
//	T2 t2;
//};
// 약간 이런 느낌으로 이루어져 있다고 생각


int main()
{
	// 연관 컨테이너
	// 벡터와 더불어서 맵도 굉장히 사용 빈도가 높음
	// 사실 배열이라거나 벡터라거나 리스트라거나 하는 것들의 단점은 뭔가 어떤 데이터를 찾아야 할때 문제가 있긴하다

	//vector<Player*> v;

	//// 10만명 입장
	//for (int i = 0; i < 100000; i++)
	//{
	//	Player* p = new Player(i);
	//	v.push_back(p);
	//}

	//// 5만명이 퇴장
	//for (int i = 0;  i < 50000; i++)
	//{
	//	int randindex = rand() % v.size();

	//	Player* p = v[randindex];
	//	delete p;

	//	v.erase(v.begin() + randindex); // 그럼 이제는 10만명이 다 온전히 있는게 아니라 중간중간 드문드문 사람들이 몇명 이렇게 빠진 상태가 될겁니다
	//}

	// (예를 들면 클라이언트 조직에서 아이디가 2만인 플레이어가 요청을 보냈는데 아이디가 1만으로 되어있는 그 해당 플레이어를 공격하고 싶어요 라는 요청을 보냈다)
	// 그럼 여기서 아이디가 10000인 플레이어를 찾아주세요 라는 요청이 오면 어떻게 해야할까

	//bool found = false;

	//for (int i = 0; i < v.size(); i++)
	//{
	//	if (v[i]->_playerId == 1000)
	//	{
	//		found = true;
	//		break;
	//	}
	//}
	// 근데 이렇게 하면 최악의 경우엔 5만번을 비교해봐가지고 서칭을 해본 다음에 결론적으로 찾았습니다하고 뱉어줄수 있겠다. 근데 이게 지금 데이터가 5만개 인데도 이런데 나중에가면 몬스터가
	// 더 많아지면 말도안되는 일이 생긴다

	// vector, list의 치명적인 단점
	// -> 원하는 조건에 해당하는 데이터를 빠르게 찾을수 없다

	// 그러면 다른 방식으로 데이터를 저장하고 있어야 하는데 그게 바로 연관 컨테이너 시리즈라고 볼수 있다
	// 연관 컨테이너
// MAP : 균형 이진 트리 (AVL)
// -  맵 또한 리스트와 같은 노드 기반으로 만들어졌다
// 균형 이진 트리라 함은 어떤 특정 노드를 기준으로 자기보다 작은 값은 왼쪽에 그리고 자기보다 큰값은 오른쪽에 타고 가면 그 데이터가 있다는것을 알수 있다
// 별다르게 어려워보이지 않을수 있는데 이게 진짜 어려워지는것은 이 균형을 맞춰주는것이 굉장히 중요하다

	srand(static_cast<unsigned int>(time(nullptr)));

	// <key, value>
	map<int, int> m;

	// 노드 기반
	class Node
	{
	public:
		Node* _left;
		Node* _right;
		// DATA
		pair<int, Player*> _data;

		// 말 그대로 우리가 어떤 데이터 타입을 이렇게 둘둘 쌍 짝 지어 가지고 이렇게 저장하는 거를 pair라고 보시면 되겠어요

		// int _key;
		// Player* _value;
		// map 라이브러리를 사용해야하고 다른 STL 문법과 비슷하게 작성한다. 
		// 대신에 꺽쇠 내의 타입은 각각 key와 value의 타입을 의미한다.
	};
	// key, value 형태로 데이터를 저장한다고 했는데 이 value는 진짜로 실질적으로 우리가 사용하는 이런 값이 되는 거고 이 key는 아까 얘기한 그 트리의 순서 그러니까 왼쪽 오른쪽 중에서
	// 어떤 노드에 저장이 돼야 될지를 뭔가 구성하는 그 위치의 역할을 하는 게 키라고 보시면 되겠다

	// 맵의 삽입과 삭제
	// 다른 문법과 비슷하게 insert, erase로 데이터를 삽입, 삭제할 수 있다. 단, 키(Key)는 고유한 값을 가진다.

	// insert는 삽입된 데이터의 이터레이터와 삽입 여부를 반환한다. 
	// 키는 고유한 값을 가지기 때문에 동일한 키로 데이터를 중복 삽입하게되면 첫 번째 이후의 삽입문은 무시되고 false를 반환한다.

	// erase는 삭제된 횟수를 반환한다.
	// 마찬가지로 이미 삭제한 데이터를 또다시 삭제하게 되면 첫 번째 이후의 삭제문은 무시되고 삭제 횟수는 0을 반환한다. 성공적으로 삭제하면 1을 반환한다.

	// insert 두 번 해보기 : 같은 키 값으로 추가할 순 없다. 두 번째 추가되는 코드가 무시된다.

	pair<map<int, int>::iterator, bool> ok;
	ok = m.insert(make_pair(1, 100)); // 1이라는 키에 100이라는 값을 추가
	ok = m.insert(make_pair(1, 200)); // 무시됨
	// 우리가 Pair로 만들어주게 될때는 첫번째 값은 first를 이용해서 꺼내주는거고 두번째 값은 second를 이용해가지고 꺼내줄수가 있다
	// 즉 인서트를 할 때는 요 부분이 굉장히 중요한데 혹시라도 만약에 우리가 이미 값이 들어가 있었다면 그 값을 만약에 바꾸고 싶었다고 하면은 요런 식으로 하면 안 된다는 얘기가 되는것이다

	// 10만명
	for (int i = 0; i < 100000; i++)
	{
		m.insert(pair<int, int>(i, i * 100)); // (i, i * 100) key는 i라는 애가 들어간거고 벨류는 i에다가 100을 곱한 값을 데이터로 저장하고 있는 상태라고 볼수 있다
	}

	// 5만명 퇴장
	for (int i = 0; i < 50000; i++)
	{
		int randomValue = rand() % 50000;

		// Erase By key
		m.erase(randomValue);
		// key값에 해당하는 노드를 삭제.
	}


	// Q) ID = 1만인 Player 찾고 싶다!
	// A) 매우 빠르게 찾을수 있음

	// erase 두 번 해보기 : 이미 삭제되면 두 번째 코드는 무시된다.
	unsigned int count = m.erase(10000); // 10000이라는 키값을 삭제. key = id
	count = m.erase(10000); // 무시됨


	// 맵의 조회와 순회

	// 조회
	// 맵에서 키 값을 이용해 데이터를 가져올 수 있다. find 함수를 사용한다.
	// m.find([Key]);
	// 맵의 이터레이터를 반환하게되며, 만약 찾지 못한 경우 end() 값을 반환한다.

	/*map<int , int>::iterator findit = m.find(10000);
	if (findit != m.end())
	{
		cout << "찾음!" << endl;
	}
	else
	{
		cout << "못찾음!" << endl;
	}*/

	// 만약 우리가 같은 키를 대상으로 erase를 햇다거나 같은 키를 대상으로 insert를 두번 한다고 하면 어떤일이 발생할까?
	// 해본것은 위에있다

	// map순회
	// 이터레이터를 활용해야한다.

	for (map<int, int>::iterator it = m.begin(); it != m.end(); ++it)
	{
		pair<const int, int>& p = (*it);
		int key = p.first; // int key = it->first; 이렇게 써도 같다
		int value = p.second; // int key = it->second; 이렇게 써도 같다

		cout << key << " " << value << endl;
	}
	// 해당 이터레이터(it)의 반환 타입은 pair이다. 각각 first와 second로 접근할 수 있다.

	// [] 연산자
	// 위에서 알아본 함수들을 조합하여 맵에 간편하게 데이터를 추가, 수정할 수 있다.키 값을 이용하여 접근한 뒤 해당 데이터가 없으면 추가를, 이미 존재하면 수정이 진행된다.
	// 없으면 추가, 있으면 수정 v1

	map<int, int>::iterator findit = m.find(10000);
	if (findit != m.end())
	{
		findit->second = 200;
	}
	else
	{
		m.insert(make_pair(10000, 200));
	}
	// 조건문을 이용해 매번 확인하고 추가, 수정하기 귀찮다면 [] 연산자를 이용하여 훨씬 간편하게 데이터에 접근할 수 있다.


	// 근데 이렇게 수정을 하고 하는 부분이 너무 귀찮다 싶으면 굉장히 유용한 그런 기능이 하나 있는데 뭐냐면은 마치 우리가 벡터에서 이미 접근을 하던 그 문법을 이용하는 겁니다
	// 없으면 추가, 있으면 수정 v2

	m[10000] = 200;   // 이 코드가 위에 써놓은 v1의 기능과 같다
	// 위의 코드는 키가 10000인 데이터가 있는 경우 200으로 수정을 해주지만, 만약 데이터가 없을 경우 키 값은 10000, 데이터는 200인 맵이 새로 추가된다는 뜻이다.
	m.clear();
	// [] 연산자 사용할때 주의
	// 만약 해당 키 값을 가지는 데이터가 없을 경우, 따로 대입을 하지 않더라도 Key/Value 형태의 데이터가 추가된다.

	for (int i = 0; i < 10; i++)
		cout << m[i] << endl;
	// 위의 코드에서 맵에 아무런 데이터도 없다고 가정할 때, 따로 대입 연산자를 사용하진 않았지만 데이터는 0으로 초기화되어 Key/Value 형태의 데이터가 맵에 새로 추가된다.
	// 만약에 진짜로 데이터가 있는지 없는지만 확인을 하고 싶었다고 하면은 요렇게 직접 이 문법을 사용해 가지고 활용을 할 게 아니라 애당초 이 find를 이용해 가지고 그 값이
	// 있는지를 체크를 해야 되는 것이다 근데 요렇게 사용하는 순간 뭔가 데이터가 실질적으로 없었다고 하더라도 
	// 이미 Key Value 형태의 데이터를 우리가 강제로 세팅을 해주는 거라고 볼 수있다

	// 새로운 컨테이너를 공부할 때는 이게 익숙해질때 까지 계속 연습을 해보는게 중요하다

	// 넣고 (insert, []) // 인서트를 하거나 아니면은 조건부적으로 만약에 없었으면은 넣고 있었으면 수정하는 부분
	// 빼고 (erase)
	// 찾고 (find, [])
	// 반복자 (map::iterator) (*it)이렇게 접근을 하게 되면 그것이 pair<key, value>& 이것을 뱉어준다

	// map은 말그대로 넣고 빼고 찾고 하는 부분이 이제 벡터와 마찬가지로 똑같이 그냥 동작을 하는 형태인데 다만 벡터나 리스트와는 다르게 굉장히 빠르게 지금 동작한다고 볼 수가있다
	// 유일하게 아쉬운 부분은 데이터를 순회해가지고 하나씩 찾는경우가 있었다고 하면 이 경우에 대해서만 사실 기본적인 맵 형태 보다는 벡터가 더 빠르게 동작 하겠지만 그냥 무식하게
	// 순회를 하는게 아니라 어떤 데이터를 특정 조건, 특정 키값에 의해 가지고 찾는 부분이 일어난다거나 아니면 중간에 있는 데이터를 삭제를 한다거나
	// 중간에 있는 데이터에다가 뭔가 데이터를 추가한다거나 이렇게 인서트를 한다거나 하면은 맵은 벡터와 다르게 뭔가 연속해서 저장이 되는 개념이 아니라 각자 뭔가
	// 이미 설정된 알고리즘에 따라가지고 트리가 재구성이 되면서 알아서 잘 빠르게 만들어지기 때문에 더 효율적인 형태로 동작하게 될겁니다

	// 그러니까 어떻게 보면은 아까 얘기한 그 플레이어나 몬스터 같은 정보를 들고 있다고 하면은 그 플레이어의 아이디에 따라가지고 그 플레이어를 빠르게 찾아야 될 때고 몬스터의 아이디에
	// 따라가지고 몬스터도 빠르게 찾아야 되는 그런 경우가 있다고 하면은 이런 맵의 활용을 고려할 수 있겠죠 그래서 키 값으로 그 해당하는 옵젝트의 아이디를 넣어주고 두 번째 값으로는 실제
	// 그 몬스터나 플레이어의 포인터를 들고 있게끔 하면 이제 벡터와는 다르게 훨씬 더 빠른 형태로 동작을 하게 될 거라는 결론을 얻을 수가 있습니다

	return 0;
}