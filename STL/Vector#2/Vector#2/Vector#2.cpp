#include <iostream> // C++ 라이브러리

using namespace std;
#include <vector>
// vector
// 면접에서 자주 물어보는 주제. 꼭 숙지
// 면접에선 특정 기능에 대해 설명하라는것 보단 원리에 대해서 질문이 할상 나오게 된다


int main()
{
	// STL은 Standard Template Library의 약자로서 프로그래밍할 때 필요한 자료구조, 알고리즘들을 템플릿으로 제공하는 라이브러리이다. 
	// 여러가지 구성요소 중 컨테이너(Container)는 데이터를 저장하는 객체, 즉 자료구조(Data Structure)를 의미한다  


	// vector
	// - vector의 동작 원리 (size/capacity)
	// - 중간 삽입/삭제
	// - 처음/끝 삽입/삭제
	// - 임의 접근

	// 반복자 (iterator) : 포인터와 유사한 개념, 컨테이너의 원소(데이터)를 가리키고, 다음/이전 원소로 이동가능
	vector<int>v(10); // 크기를 10으로 설정

	v.reserve(1000);
	// vector<int>::size_type : size_type을 이용하면 알아서 알맞는 타입을 정해준다 
	for (vector<int>::size_type i = 0; i < v.size(); i++)
	{
		v[i] = i; // 1 2 3 4 5 6 7 8 9 저장
	}

	//vector<int>::iterator it; // 디버깅해서 it안에 뭐가 있는지 까보면 묘한 값들이 들어 있는것을 알수 있다. 
	//// 즉 내가 지금 어떤 컨테이너에 소속되어 있는지를 이런 식으로 들고 있다고 보면된다
	//// iterator는 내부적으로 포인터 자체를 들고있다
	//int* ptr;

	//it = v.begin();
	//// begin : 배열의 첫 요소를 가리키는 Iterator(포인터(주소값))를 반환한다.
	//ptr = &v[0];
	//
	//cout << (*it) << endl;
	//cout << (*ptr) << endl;

	//it++; // 포인터 연산처럼 이터레이터도 똑같은 의미를 한다, 다음 데이터로 넘어가라는 의미
	// it++ 보다 ++it이 조금 더 성능이 좋다. (Iterator ++ 연산자 오버로딩 차이)
	//int b = a++; // (b =1, a=2)
	//int c = ++a; // (c = 2, a = 2)

	/*++it;

	it += 2;

	ptr++;
	++ptr;*/

	vector<int>::iterator itBegin = v.begin();
	vector<int>::iterator itEnd = v.end();
	// end : 배열의 마지막 요소의 다음을 가리키는 Iterator(포인터(주소값))를 반환한다.

	for (vector<int>::iterator it = v.begin(); it != v.end(); ++it)
	{
		cout << (*it) << endl;
	}

	int* ptrbegin = &v[0]; // v.begin()._Ptr; 이 버전과 똑같은 얘기
	int* PtrEnd = ptrbegin + 10; //  v.end();._Ptr; 이 버전과 똑같은 얘기
	for (int* ptr = ptrbegin; ptr != PtrEnd; ++ptr)
	{
		cout << (*ptr) << endl;
	}
	// 위 버전과 똑같은 기능

	// 즉 이터레이터라는것은 내부적으로 포인터가 숨겨져 있다라고 볼수가 있다
	// 그리고 이터레이터는 그냥 포인터만 생으로 들고 있는 것 뿐만아니라 이 이터레이터가 진짜로 소속이 된 그런 컨테이너의 정보도 여기 내부적으로 들고 있다

	// 더 복잡해보이는데 굳이 사용을 해야할까?
	// 👉 Iterator는 벡터 뿐 아니라, 다른 컨테이너에도 공통적으로 있는 개념이다.
	// 다른 컨테이너는 벡터와 다르게 v[i]와 같은 인덱스 접근이 안 될 수도 있다.
	// STL 한정으로 통일성이 생기기 때문에 다른 자료구조로 넘어가기가 용이하다.

	vector<int>::const_iterator cit1 = v.begin();
	// *cit1 = 100; => error
	// const_iterator : const int*와 동일한 의미. 데이터를 onlyread 할 경우에 사용한다.
	for (vector<int>::reverse_iterator it = v.rbegin(); it != v.rend(); ++it)
	{
		cout << (*it) << endl;
	}
	// reverse_iterator : 역방향으로 배열을 탐색한다
	// 숫자를 거꾸로 출력

	//-----------------------------------------------------------------------------

	// - 중간 삽입/삭제 (BAD)
	// - 처음/끝 삽입/삭제 (BAD(처음) / GOOD(끝))
	// - 임의 접근(Random access) (GOOD)

	// 위의 내용들은 면접에서 가장 만만하게 물어보기 쉬운것
	// 위의 내용들에 대해 이해를 못한다고 하면 그냥 애당초 기본기가 없던 얘기

	// vector = 동적 배열 = 동적으로 커지는 배열 = 배열
	// 원소가 하나의 메모리 블록에 연속하게 저장된다!

	// 중간 삽입과 삭제
	// 배열의 중간을 건드리는 일은 상당히 비효율적이다.
	// 중간에 새로운 값을 삽입하거나 삭제하게되면 뒤에 있는 모든 데이터가 한 칸씩 앞당겨지거나 뒤로 밀리게된다.
	// 메모리를 많이 차지하는 배열일수록 데이터의 이동이 많아지게된다.그래도 가능은한데 다른 함수보다 사용법이 복잡하다.
	// 그래서 결론적으로 벡터의 중간 삽입 삭제는 굉장히 비효율적으로 동작한다라는 걸 알 수가 있다

	// 중간 삽입
	//vector<int>::iterator insertIt = v.insert(v.begin() + 2, 5); // insertIt 얘가 뱉어주는 값은 내가 정확하게 추가한 위치, 주소를 가리키고 있다
	// 중간 삭제
	//vector<int>::iterator eraseIt1 = v.erase(v.begin() + 2);  // eraseIt1 얘가 반환해주는것은 정확하게 삭제한 위치를 뱉어준다
	//vector<int>::iterator eraseIt2 = v.erase(v.begin() + 2, v.begin() + 4); // v.begin() + 4 ,마지막은 포함 안 됨 , eraseIt2 얘가 반환해주는것은 정확하게 삭제한 위치를 뱉어준다

	// insert : 삽입
	// 첫 번째 인자 : 값을 추가할 위치(iterator)
	// 두 번재 인자 : 추가할 값
	// erase : 삭제
	// 단일 인자 : 삭제할 값의 위치(iterator)
	// 첫 번째 인자 : 삭제할 값의 시작 위치(iterator)
	// 두 번째 인자 : 삭제할 값의 마지막 그 다음 위치(iterator)

	// erase는 함수 재정의가 되어있고 범위를 지정하기 위해 두 개의 인자를 받을 때, 두 번째 인자에 해당하는 값은 삭제되지 않는다.

	// 처음 / 끝의 삽입과 삭제
	// 처음 부분의 삽입과 삭제는 중간 삽입, 삭제와 동일한 동작을 한다.맨 앞의 값을 추가하게되면 뒤의 모든 데이터가 한 칸씩 뒤로 밀리게 되고 
	// 맨 앞의 값을 삭제하게되면 뒤의 모든 데이터가 한 칸씩 앞당겨지게 된다.중간 삽입, 삭제와 같이 비효율적이다.
	// 반면, 끝의 삽입과 삭제는 편리하고 효율적이다.그래서 함수 사용법도 간편하다.
	// 그래서 유일하게 제공하는 인터페이스는 뒤에다가 밀어넣고 뒤에다가 있는 걸 삭제를 하는 걸 지원한다

	// 끝의 삽입
	v.push_back(1);
	// 끝의 삭제
	v.pop_back();


	// 3번째 데이터는 어디 있나?
	v[2] = 3;

	// 이렇게 임의 접근(Random Access)는 아무 값이나 쉽게 접근한다는 뜻으로 벡터와 같은 배열에서 지원한다.
	// 배열은 데이터를 쉽게 찾기 위해 원소가 하나의 메모리 블록에 연속하게 저장된다는 특징이 있다. 이러한 특징이 임의 접근을 가능하게끔 해주는 것이다.

	// 쭉 ~ 스캔을 하면서 . 3이라는 데이터가 있으면 일괄 삭제하고 싶다

	for (vector<int>::iterator it = v.begin(); it != v.end(); /*++it*/)
	{
		int data = *it;
		if (data == 3)
		{
			it = v.erase(it); // 이렇게 하면 이터레이터는 erase를 하는 순간 유효하지 않기 때문에 이 데이터하나만 고치고 끝날거면 무조건 브레이크 문을 넣어준다거나 하는 식으로 빠져나와야함
			// 만약 그게 아니라 계속 나머지 데이터들도 하나하나씩 체크를 하고 싶다고 하면은 여기서 이레이스하는 딱 그 위치를 다시 뱉어줄 거기 때문에 얘를 이런 식으로 다시 받아와야 된다는
			// 얘기가 된다 it = v.erase(it); 이렇게.
			// 근데 이렇게만 하면 문제가 되는 부분이 뭐냐면 디버깅을 해보면 이레이스를 한후 반환한 위치에 4를 가리키고 있는데  ++it 이것 때문에 4는 체크도 안하고 바로 넘어간다는 문제가 생김
		}
		else
		{
			++it; // 그래서 이렇게 만들어 줘야함
		}
		// 그리고 굉장히 중요한 얘기는 for문을 이용해서 이터레이터를 쫙 스캔을 하는 도중에 여기서 뭔가 데이터를 조작해가지고 뭔가 데이터를 푸쉬를 한다거나 아니면 
		// 클리어를 한다거나 하는 코드가 등장하면 그때는 굉장히 조심해야 된다는 얘기가 되겠습니다. 이렇게 이레이스를 할 거면 반드시 그 이터레이터를 다시 받아와야 되는 거고 
		// 클리어를 할거면 애당초 더 이상 이터레이터가 하나도 없게 다 날아가게 되는 거니까
		// v.clear(); 그래서 이런짓을 하면 안됨. 했다고 하면
		// break; 이렇게 끝내줘야함

	}




	return 0;




}