#include <iostream> // C++ 라이브러리

using namespace std;
#include <vector>
// vector
// 면접에서 자주 물어보는 주제. 꼭 숙지
// 면접에선 특정 기능에 대해 설명하라는것 보단 원리에 대해서 질문이 할상 나오게 된다


int main()
{
	// STL은 Standard Template Library의 약자로서 프로그래밍할 때 필요한 자료구조, 알고리즘들을 템플릿으로 제공하는 라이브러리이다. 
	// 여러가지 구성요소 중 컨테이너(Container)는 데이터를 저장하는 객체, 즉 자료구조(Data Structure)를 의미한다  


	// vector
	// - vector의 동작 원리 (size/capacity)
	// - 중간 삽입/삭제
	// - 처음/끝 삽입/삭제
	// - 임의 접근

	// 배열
	/*const int MAX_SIZE = 10;
	int arr[MAX_SIZE] = {};

	for (int i = 0; i < MAX_SIZE; i++)
		arr[i] = i;
	for (int i = 0; i < MAX_SIZE; i++)
		cout << arr[i] << endl;*/

		// 동적 배열
		// 매우매우 중요한 개념 -=> 어떤 마법을 부렸길래 배열을 '유동적으로' 사용한 것인가?
		// 우선, 동적 배열인 벡터는 메모리를 할당할 때 여유분을 두고 메모리를 할당한다. 여기까진 일반 배열과 별다른 차이점이 없지만, 
		// 여유분까지 꽉 찼으면 메모리를 증설한다는 차이점이 있다. 일반 배열은 한 번 설정한 배열의 크기에서 더 늘릴 수 없다.

		// Q1) 여유분은 얼만큼이 적당할까?
		// Q2) 증설을 얼만큼 해야할까?
		// Q3) 기존 데이터를 어떻게 처리할까?


		// 벡터(Vector)는 동적 배열을 의미한다. 동적 배열은 말 그대로 배열은 배열이지만 동적으로 변화하는 배열이다. 
		// 우리가 이제껏 사용해왔던 배열은 정적 배열로 크기가 고정되어있기 때문에 데이터를 추가로 담거나 삭제하는 등 유동적으로 관리해야 할 경우 관리가 힘들다는 단점이 있다. 
		// 이러한 단점을 보완한 것이 바로 동적 배열인 벡터이다.
		// vector<[타입]> [변수명];
		// ex
		// 벡터를 사용할 땐 vector 라이브러리를 추가해줘야 한다.
		//vector<int> v;
		//v.push_back(1);
		//v.push_back(2);
		//v.push_back(2); // 배열에 2라는 요소를 추가
		//v.push_back(4); // 배열에 4라는 요소를 추가
		//v.push_back(5);
		// push_back : 배열에 요소를 추가한다.
		//const int size = v.size();
		// size : 배열의 크기를 반환한다.(들어가있는 데이터의 개수)

		//for (int i = 0; i < size; i++)
		//{
		//	cout << v[i] << endl; // 1, 2,3,4,5 출력
		//}


		// 1) vector의 동작 원리 (size/capacity)
		// size : 실제 사용 데이터 개수
		//  1 2 3 4 5 6 7 8 ....
		// capacity : 여유분을 포함한 용량 개수
		// 1 2 3 4 6 9 13 19 28..
		// size는 배열의 요소가 채워지면서 1씩 증가하는 걸 알 수 있고 capacity는 처음엔 1씩 늘어나다가 대략적으로 1.5배씩 증가하는 것을 알 수 있다.
		//v.capacity();

		// 우선 벡터도 배열은 배열이므로 연속된 메모리에 값이 저장되어야한다. 
		// 첫 생성 시 임의의 (여유분을 포함한) 메모리를 할당받은 후 데이터를 차곡차곡 쌓아가다가 여유분까지 모두 사용하게되어버리면 더 큰 메모리 공간으로 이사를 하게 되는 것이다. 
		// 기존에 있던 데이터들은 그대로 복사 이동된다.
		// 잦은 복사가 이루어지면 아무래도 효율적인 측면에서 좋지 않으니 capacity를 초기에 세팅해줄 수 있는데, reserve 함수를 사용하여 설정해줄 수 있다.

		//v.reserve(1000); // 면접에서 종종 나오는 개념
		// 위의 코드는 처음부터 capacity를 1000으로 설정해달라는 의미이다. 
		// 이렇게 설정하게되면 사이즈가 1000이 될 때까지 메모리를 이동하지 않아 효율적인 측면에서 좋지만 사이즈와 다르게 한 번 늘어난 용량은 다시 줄어들지 않는다

		// 벡터 선언과 동시에 사이즈 및 데이터를 지정해줄 수도 있다.
		// resize 1000, 데이터는 0으로 초기화
	vector<int> v(1000, 0);
	vector<int> v2 = v;

	// 벡터는 일반 배열과 달리 통째로 대입연산이 가능하다
	// 왜냐면 배열은 고정크기의 메모리 블록이며 기본적으로 포인터처럼 기능을 한다
	// 배열 이름은 배열의 시작 주소를 나타낼 뿐, 데이터를 직접적으로 관리하거나 대입 연산자를 오버로드하지 않습니다.
	// 그래서 배열 간의 대입 연산이 기본적으로 허용되지 않습니다. 

	// 근데 벡터는 내부적으로 데이터를 관리하기 위해 메모리 관리와 동작을 정의하는 멤버 함수와 연산자를 포함합니다.
	// 특히, 대입 연산(=)은 대입 연산자 오버로드를 통해 벡터의 요소를 복사하는 동작이 정의되어 있습니다.

	// 벡터의 대입연산
	// 원래 벡터의 내용을 비운다.
	// 대입된 벡터의 크기와 내용을 현재 벡터로 복사한다.
	// 필요하다면, 내부 데이터를 저장하기 위해 새로운 메모리를 할당한다.

	v.resize(1000); // size 1000개에서 시작
	// 그래서 실제 데이터 개수는 1000개에서 시작이고, 요소들은 전부 0으로 채워져 있다
	cout << v.size() << " " << v.capacity() << endl;
	// resize를 이용해 사이즈도 세팅시켜줄 수 있다

	// reserve : capacity의 크기를 설정해준다.
	// resize: size의 크기를 설정해준다.
	for (int i = 0; i < 1000; i++)
	{
		//v[i] = 100; // 이미 잡혀있는 영역에 접근해서 활용을 한다는 의미 

		v.push_back(100); // 데이터를 추가하는 의미 , 데이터를 추가해서 사이즈는 1001이 되었다
		cout << v.size() << " " << v.capacity() << endl;
	}

	v.clear();
	// clear : 배열의 모든 데이터를 삭제한다. 먄약, 늘어난 capacity도 같이 초기화하고 싶으면 swap 함수를 이용한다.
	vector<int>().swap(v);
	cout << v.size() << " " << v.capacity() << endl;

	// -이 외에도 다양한 함수들이 존재한다.
	// front : 배열의 첫 요소를 출력한다.
	// back: 배열의 마지막 요소를 출력한다.
	// pop_back : 배열의 마지막 요소를 삭제한다.


	return 0;




}