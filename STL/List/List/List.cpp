#include <iostream>
#include <vector>
#include <list>
using namespace std;

// Node[_data(4) next(4/8) ]
// 단일 연결 리스트
//class Node
//{
//public:
//
//    Node* _next; // Node _next; 이렇게 쓰면 설계도를 완성하려면 건물을 완성시켜야한다는 소리랑 똑같으므로 말이 안되서 쓰면안됨
//    int _data;
//};
// _data에는 해당 노드의 정보가 담겨있고 _next에는 다음 노드의 주소값이 들어있다. 
// 위의 설계도는 단일 연결 리스트일 때를 의미하고 이중 연결 리스트나 원형 연결 리스트라면 이전 노드의 주소값이 추가로 들어있다고 볼 수 있다.

class Node
{
public:
    Node* _next;
    Node* _prev;
    int _data;
};
int main()
{
    // 벡터는 동적 배열 방식이지만 리스트는 노드방식이다
    // 그리고 리스트를 공부하면 자료구조들을 이해하는데 많은 도움이 된다
    // 그리고 면접에서도 벡터와 리스트의 차이는 거의 0순위로 등장하는 그런 단골 주제

    // 리스트(List)는 STL 컨테이너 중 하나이며 연결 리스트(Linked List)라고도 불리며 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트가 있다. 벡터와 비슷하지만 사용 빈도는 벡터보다 낮다.

    // List (연결 리스트)
    // - List 의 동작 원리

    // 단일 연결 리스트 
    // [1]   ->   [2]   -> [3]  ->  [4]

    // 이중 연결 리스트 
    // [1]   <->   [2]   <-> [3]  <->  [4]  <-> [ _Myhead : end() ](더미 노드) <-> // 그리고 얘가 이렇게 양옆으로 이거의 전으로 가면은 우리 마지막 데이터가 있고, 
    // 후로 이렇게 넘어가게 되면은 이 처음 노드로 이렇게 연결이 되어 있다는 걸 볼 수 있다 
    // [ _Myhead : end() ] => 더미 노드. 코드를 살펴보면은 MyHead라는 이름으로 되어 있는데 
    // 얘가 바로 우리가 리스트에서 엔드를 할 때 가리켜주는 그 노드라고 볼 수가 있는 거죠. 그래서 끝났다는것을 표현하기 위해서 이렇게 더미 노드를 만들어준 상태이다

    // 리스트는 동적 배열이 아닌 일종의 노드들로 이루어진 형식이다. 
    // 배열처럼 메모리에 데이터가 연속적으로 존재하지 않고 위치는 각자 달라도 각 노드가 다음 주소의 정보를 가지고 있어 서로 연결되어있는 식이다. 
    // 단일 연결 리스트는 단방향으로만, 이중 연결 리스트는 양방향으로, 
    // 원형 연결 리스트는 이중 연결 리스트에 추가적으로 마지막 요소가 첫 번째 요소를 가리키는 순환식으로 설계되어있다


    // - List 의 동작 원리
    // - 중간 삽입/삭제
    // - 처음/끝 삽입/ 삭제
    // - 임의 접근

    // 벡터처럼 리스트 라이브러리를 추가해줘야 사용이 가능하고 사용 방법은 벡터와 똑같다.
    // 자 그러면은 이렇게 처음에 새로운 기능을 공부를 할 때는 그냥 점을 찍어 가지고 얘가 어떤 기능을 제공하는지 이렇게 하나씩 살펴보는 게 좋습니다
    // 이걸 외우려고 하지 말고 하나씩 하나씩 사용하다 보면 조금씩 이제 자기가 외우는 그 영역이 넓어지게 됩니다

    list<int> li;

    for (int i = 0; i < 100; i++)
    {
        li.push_back(i);
    }
    //li.push_front(10);

    // push_back : 가장 뒤에 요소를 추가한다.
    // push_front: 가장 앞에 요소를 추가한다., 지원하는 이유는 처음에 데이터를 삽입하는게 아무런 부담이 없기 떄문이다
    // 벡터 같은 경우에는 푸쉬 프론트를 지원을 하지 않았었죠 그리고 지원하지 않는 이유는 말 그대로 벡터 같은 경우에는 처음에 어떤 삽입 혹은 삭제를 하는 부분이 굉장히 비효율적이기 때문에 
    // 그렇게 라이브러리 차원에서 혹시라도 착각할까봐 지원하지 않았다고 한다면 리스트 같은 경우에는 푸시 프론트를 지원한다는 것 자체가 일단은
    // 벡터와는 다르게 푸시 프론트가 어느 정도 효율적으로 동작한다는 걸 일단은 예측할 수가 있다
    int size = li.size();
    //li.capacity(); // 없음. 벡터와 다르게 capacity 함수는 존재하지 않는다. 왜냐면 여유 공간을 잡아가지고 뭔가를 만들어주는 개념이 아니라 
    // 그냥 필요할 때마다 실시간으로 노드 하나를 이렇게 추가를 해 줘 가지고 연결을 해주는 개념이기 때문에 Capacity라는 개념이 없다

    int first = li.front();
    int last = li.back();

    // li[10] = 10; // 없음

    // size: 리스트의 크기를 반환한다.
    // front : 가장 첫 번째 요소를 반환한다.
    // back : 가장 마지막 요소를 반환한다.
    // begin : 가장 첫 번째 요소를 가리킨다.
    // end : 가장 마지막 요소의 다음 주소를 가리킨다.
    // insert : 특정 위치에 요소를 추가한다.
    // erase : 특정 위치에 있는 요소를 삭제한다.
    // pop_back : 가장 마지막 요소를 삭제한다.
    // pop_front : 첫 번째 요소를 삭제한다.
    // remove : 특정 값과 일치하는 모든 요소를 일괄 삭제한다.

    // 이런 기능들은 어거지로 당연히 외울 필요가 없다 이런 것들은 가장 중요한 거는 역시나 리스트의 동작 원리를 이해하는 게 가장 중요한데 리스트의 동작 원리에 대해서만 숙지를 하고 있다고 하면은 
    // 이런 애들이 왜 이렇게 동작하는지 명확하게 이해가 갈것이다

    list<int>::iterator itBegin = li.begin();
    list<int>::iterator itend = li.end();

    // 반복자에 대하여
    //list<int>::iterator itTest1 = --itBegin;    // error
    //list<int>::iterator itTest2 = --itend;      // O
    //list<int>::iterator itTest3 = ++itend;      // X

    // 리스트에서 이터레이터는 벡터와 다르게 제한되는 기능이 많다. 연속되어 저장된 게 아니기 때문에 임의의 수를 직접 더하는 연산은 불가능하다.

    //list<int>::iterator it = li.begin() + 10;   // 벡터는 가능하지만 리스트는 불가능하다. 진짜로 얘를 하나씩 타고 가 가지고 워프를 타고 타고 타고 가 가지고 한 땀 한 땀 한 땀
    // 이렇게 열 번씩 이동하는 것 밖에 방법이 없습니다

    // 이전 노드의 주소와 다음 노드의 주소는 알고 있기 때문에 1씩 더하거나 빼는 것은 증감 연산자를 이용한다면 가능하다.
    // 단, 첫 노드의 이전 주소로 이동한다거나 마지막 노드의 다음 주소로 이동하는 것은 불가능하다. 
    // 이중 연결 리스트의 경우 마지막 노드의 다음 주소엔 더미 노드(헤더 노드)가 연결되어 있다. 
    // 리스트의 마지막 노드의 다음 주소인 end() 값이 들어있는 노드이다. 그래서 원형이 아닌 이상 첫 노드와 마지막 노드 간의 이동은 불가능하다.

    int* ptrBegin = &(li.front());
    int* ptrEnd = &(li.back());

    for (list<int>::iterator it = li.begin(); it != li.end(); ++it)
    {
        cout << *it << endl;
    }

    //li.insert(itBegin, 100); // 가장 첫번쨰 요소에 100을 집어넣는다

    //li.erase(li.begin()); // 첫번째 요소를 지운다

    //li.pop_front(); // 첫번째 요소를 삭제한다

    //li.remove(10); // 원래 9번인덱스에 10이 있었는데 이 코드가 10이 들어있는 값을 삭제해서 이젠 9번인덱스엔 11이 들어있다

    // 벡터에서 지원을 안해주는 이유는 벡터 같은 경우는 중간에 있는 값을 삽입하거나 삭제하는 게 굉장히 비효율적으로 일어나기 때문에 애당초 그거를 막 난발하지 않도록 
    // 벡터에는 이런 기능을 열어두지 않았다고 볼수 있다

    // - 중간 삽입/삭제 (GOOD / GOOD)
    // - 처음/끝 삽입/ 삭제 (GOOD / GOOD) - 빠르게 작동
    // - 임의 접근 (i번째 데이터는 어디있나) - 느림(BAD)

    // 리스트 같은 경우는 애당초 이런 모든 노드들이 다 연속된 공간을 차지할 필요가 없다는 얘기가 되는 거니까 
    // 이렇게 서로 떨어져 있어도 아무 상관이 없죠 단지 포인터만 서로 연결시켜주면 된다

    // 삽입과 삭제
    // 이러한 리스트의 구조는 벡터와 다르게 중간 삽입, 삭제 그리고 처음의 삽입, 삭제가 아주 간편하고 빠르다.
    // 리스트의 삽입과 삭제는 노드가 저장하고 있는 포인터의 값만 변경해주면 쉽게 할 수 있다.

    // 단, 중간 삽입, 삭제가 빠르다는 것은 해당 위치를 알고있다는 전제하에 성립되는 설명이다.
    // 지점을 확실하게 알지 못하면 반복문을 통해 탐색을 하는 과정이 필요하게되고 그로 인해 탐색이 느리다는 설명이 성립된다.탐색 부분과 삽입, 삭제 부분을 나눠서 이해해야 할 필요가 있다.

    // 예를 들어, 이중 연결 리스트가 이렇게 있다고 할때, 100이라는 숫자를 들고 있는 새로운 노드를 만들어준 다음에 2번 노드를 찾아서 2번노드의 next가 우리가 만들어준 100이라는 값의 노드를
    // 가리키게끔 조작을 해주면 됨
    // [1]   <->   [2]   <-> [100] <->  [3]  <->  [4]
    // 마찬가지로 100이라는 값을 가진 노드를 삭제한다고 한다면, 
    // 100이라는 노드기준으로 앞뒤의 노드가 무엇인지를 알다 보니까 이전 노드의 next값을 이 3번을 가리키게끔 포인터를 조작해주고 마찬가지로 3이라는 값을 갖고 있던 그 노드도 
    // Previous 값이 지금은 이 100을 갖고 있는 노드로 되어 있지만 그게 아니라 이 2라고 되어 있는 요 아이를 가리키게끔 포인터를 조작해 줘 가지고 
    // [2]를 가리키게끔 만들어 주게 되면 결국에는 이런 식으로 100이라는 존재를 양옆으로 있게 될 거니까 이렇게 만들어 주게 되면 나머지 데이터들은 건들 필요도 없이 
    // 이 형태가 다시 복구가 된다는 얘기가 되겠습니다

    // 하지만 벡터와 달리 리스트의 구조가 자유로운 대신 데이터가 정리되어있지 않고  이런 데이터들이 다 서로 떨어져 가지고 저 멀리 어딘가에 이렇게 분리되어서 저장이 된 상태이다. 
    // 단지 포인터를 이용해서 주소로 넘어갈수 있게끔 저장해준 상태라는 차이가 있을 뿐이다
    // 임의 접근(Random Access)이 불가해 동적 배열보다는 탐색하기 어렵다.

    // 만약에 이 인덱스가 3번인 i 를 찾고 싶다고 하면은 딱히 뾰족한 방법이 없습니다 그냥 이 처음부터 0번부터 시작해 가지고 한 칸, 두 칸, 세 칸 이런 식으로 직접 이렇게
    // 워프를 타고 계속 앞으로 이동을 해보는 수밖에 없기 때문에 그래서 이런 이미 접근과 관련된 연산자들이 일단은 기본적으로 막혀있다고 볼수 있다

    // 자료구조나 알고리즘적으로 그냥 이해하지 않고 달달 외우다 보면 별로 안좋으니 꼭 이해하자
    // 꼭 원리를 아는것이 중요하다

    // 임의 접근이 느리다고 했는데 중간삽입/삭제 빠를수 있나?

    // 예시
    // 만약, 50번 인덱스에 있는 데이터를 삭제!
    list<int>::iterator it = li.begin();
    for (int i = 0; i < 50; i++)
    {
        ++it;
    }

    li.erase(it);
    // 이렇게 되면 삭제가 빠르다는 말이지 이미 접근을 해서 그 데이터를 찾는거는 전혀 빠르지 않다는 모순이 발생한다
    // 그렇기 때문에 여기서 이해해야 되는 게 굉장히 중요한 부분은 뭐냐면 그냥 우리가 임의의 숫자를 하나 줘가지고 예를 들면 지금 이런 식으로 50번째에 있는 데이터를 삭제해줘 라고
    // 하면 얘는 어쩔 수 없이 찾은 다음에 삭제를 해야 되기 때문에 전혀 빠르지 않게 되겠지만 그런데 거꾸로 우리가 애당초 삭제를 할 대상을 이런 식으로 어떤 이토레이터와 같은 형식으로
    // 들고 있는 상태라고 한다면 이렇게 찾지 않는다고 하더라도 이 이레이스 자체는 굉장히 빠르게 동작한다는 게 되는 거죠
    // 그러니까 접근 부분이랑 삭제 부분을 이제 분리해서 생각을 해야 되겠습니다

    list<int>::iterator itRemember;

    for (int i = 0; i < 100; i++)
    {
        if (i == 50)
        {
            itRemember = li.insert(li.end(), i);
        }
        else
        {
            li.push_back(i);
        }

    }
    // 이렇게 하면은 우리가 지금 삭제를 할 위치를 이렇게 이터레이터로 기억을 하고 있는 상태가 되는 거니까 이거를 이용해 가지고 나중에 나중에 언젠가 이런 식으로 이레이스를 한 방에 뿅
    // 처리를 하게 되면은 굳이 이렇게 이미 접근과 같은 예를 들어 하나씩 하나씩 서칭해 가지고 내가 원하는 삭제할 데이터를 찾는 게 아니라 그냥 그 데이터 자체를 이렇게 한 번에 삭제는
    // 할 수 있다는 얘기가 되는 겁니다
    // 그렇기 때문에 중간 삽입 삭제가 빠르다고 하는 거지 절대로 우리가 원하는 특정 몇 번 인덱스에 데이터를 삭제해달라는 이 풀세트가 빠르다는 건 아니라는 얘기가 되는 것 같습니다
    return 0;
}