#include <iostream>
using namespace std;
#include <vector>
#include <list>
#include <deque>
// 오늘의 주제 : list

// 리스트 구현

// vector : 동적 배열
// [           ]

// list: 이중 연결 리스트로 구현됨
// [ ] <-> [ ] <-> [ ]

// deque : double-ended queue 데크
// [   ]
// [   ]
// [   ]
// 사용방법은 벡터, 리스트와 동일하다. deque 라이브러리를 사용한다.

int main()
{
	// 지금까지 알아본 시리즈 들이 시퀀스 컨테이너(vector, list, deque)라고 불리는 애들이다
	// Sequence Container
	// 시퀀스 컨테이너는 일단 데이터를 넣은 순서대로 그냥 쭉 나열되서 정렬이 되는 형태라고 보면된다

	// deque의 동작 원리
	// 덱은 double - ended queue의 축약어로 ‘양쪽을 모두 사용할 수 있는 큐’ 정도로 해석할 수 있다.
	// 일정 크기의 메모리를 우선 할당받은 후 벡터처럼 연속하여 데이터를 저장하지만, 
	// 데이터가 모두 찼을 때 앞 뒤로 데이터를 추가하게되면 해당 방향으로 자유롭게 새 메모리를 할당받아 저장하는 식이다.
	// 양 옆으로 사용이 가능한 벡터 같은 느낌이 강하고 이는 곧 벡터쪽에 더 가깝다고 볼 수 있다.
	// 다만, 덱은 벡터와 마찬가지로 배열 기반으로 동작하지만 메모리 할당 정책이 다르다.

	// vector
	// [   ]    ]
	// [1 1 1]

	// deque 
	// [1 1 1]

	vector<int> v(3, 1);
	deque<int> dq(3, 1); // 크기는 3이고 초기값은 1인 애들로 만들어짐

	// deque
	// [    3 3]
	// [1 1 1 2]
	// [2      ]
	v.push_back(2);
	v.push_back(2);
	// 백터같은 경우에 사이즈도 3이고 캐페시티가 3인 상태에서 이 상태에서 데이터를 하나를 추가하는 순간 F10을 눌러볼 건데 기존에 있던 메모리가 싹 날아가는 걸 볼 수가 있습니다
	// 그리고 다시 한번 아까 복붙한 첫 번째 데이터의 주소를 딱 살펴보면 다른 영역에 이런식으로 1112가 들어가 있는걸 볼수 있고 한번더 푸시백을하면 아까 그랬던것처럼 똑같이 이 영역도 날아가서
	// 더 큰 영역으로 이전을 한다

	dq.push_back(2);
	dq.push_back(2);

	dq.push_front(3);
	dq.push_front(3);

	// 덱의 푸시백을 보면은 신기하게도 기존에 있던 데이터는 아무런 변화가 없다는 걸 볼 수 있다. 그러니까 말 그대로 얘네들을 이전하고 이런 개념이 아니라 이제 통이 꽉 찼다
	// 싶으면 새로운 통 하나를 또 새로 만들어 가지고 거기다가 다음 데이터를 만들어 준다는 걸 볼수 있다


	// 덱은 그 여유분을 할당하는 게 아니라 그냥 필요필요할 때마다 이런 식으로 뭔가 어떤 통을 늘려 가지고 거기다가 새로운 데이터를 밀어 넣는 형태이기 때문에 
	// 딱히 용량 개념은 없다는 걸 알 수가 있어요

	// 그러니까 요약을 하자면, 처음에는 4칸짜리로 데크가 일단 있는건데 이 통 자체가 데이터를 4개를 담을수 있는 상태였다.  
	// 근데 우리가 지금 3개만 이렇게 담아준 상태였고 여기다가 푸시백을 하나 해가지고 일단 2를 밀어 넣어주면은 일단 데이터가 4개에 꽉 찬 상태가 되는 거죠
	// 그다음 푸시백을 한번 더하면 이제 꽉찬 상태이니까 더이상 데이터를 밀어 넣을수 없다 보니까 통 자체를 하나 새로 파준 다음에 새로운 값을 넣어준게  [2      ] 이부분이다
	// 마찬가지로 푸쉬 프런트를 할때도 꽉찬샹태라서 새로 통을 하나 만들어줘서 [    3 3] 이렇게 데이터를 넣어준 상태라고 볼수 있다

	// 그래서 벡터와는 굉장히 다르게 동작한다는 걸 알 수 있는 거죠 벡터 같은 경우에는 무조건 하나의 통에서 이 통 사이즈를 늘렸다가 줄였다가 하면서 늘렸다가 그 다음에 나머지
	// 있던 부분들을 복사하는 식으로 동작을 했다면 얘는 뭔가 앞뒤로 계속 통을 이렇게 늘릴 수 있다는 특징이 있다 보니까 배열은 배열이지만 굉장히 다르게 동작하다는 걸 알 수가 있는것이다

	deque<int> dq;

	dq.push_back(1);
	dq.push_front(2);
	cout << dq[0] << endl;

	// - 중간 삽입/삭제 (Bad/ Bad)
	// 벡터와 동일하게 동작하기 때문에 비효율적이다. 중간에 값을 건드리게되면 양 옆으로 존재하는 수많은 데이터의 이동이 이루어지게 된다.

	// - 처음/끝 삽입/삭제 (GOOD/ GOOD)
	// 현재 메모리 블록의 데이터가 전부 찼다고 해도 양 옆으로 새 메모리를 할당받아 저장하기 때문에 처음, 끝의 삽입과 삭제는 빠른편이다. 
	// 벡터의 경우는 앞에다가 데이터를 밀어 넣거나 삭제하는것이 느렸었다

	// - 임의 접근 (Good)
	// 그리고 벡터와 같이 임의 접근이 가능하다.

	dq[3] = 10;
	cout << dq[3] << endl;


	return 0;
}