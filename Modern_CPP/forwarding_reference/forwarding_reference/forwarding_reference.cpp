#include <iostream>
using namespace std;
#include <vector>
#include <list>
#include <deque>
#include <map>
#include <set>
#include <algorithm>

// 전달 참조 (forwarding reference)

class Knight
{
public:
	Knight() { cout << "기본 생성자" << endl; }
	Knight(const Knight&) { cout << "복사 생성자" << endl; }
	Knight(Knight&&) noexcept { cout << "이동 생성자" << endl; }
};

void Test_RvalueRef(Knight&& k)// 오른값 참조
{

}
// &&가 두 번이 등장하면은 무조건 오른값 참조일까가 사실 오늘의 주제라고 볼 수가 있다

void Test_copy(Knight k)
{

}

template<typename T>
void Test_ForwardingRef(T&& param) // 전달 참조 , 만약에 인수에다가 이렇게 const T&& param 해주면 얘는 더 이상 전달 참조로 동작하지 않고 오른값 참조로 돌변하게 된다.
{
	// TODO
	// move(param); // 처음에 넘겨줄때 왼쪽값을 넘겨줬다고 하면 이런식으로 무브를 하면 큰일이 난다
	// 무브를 한다는건 원본을 훼손시키고 정보만 가져가겠다라는 건데 왼쪽값은 원본이 유지되어야하는 상황인데 얘를 실행하면 안된다
	// 그래서 그러면 왼값이냐 오른쪽 값이냐에 따라 가지고 뭔가 이렇게 같이 동작을 하는 그런 기능이 일단은 필요하다고 보시면 되겠습니다

	// 왼값 참조라면 복사
	//Test_copy(param);

	// 오른쪽 참조라면 이동
	//Test_copy(move(param)); // 이렇게 무브를 써주면 이동생성자가 호출이 된다


	// std::forward
	// 위에서 만들었던 함수같은 경우 왼값 참조 타입의 값을 받을 때도 있고 오른값 참조 타입의 값을 받을 때도 있다.
	// forward를 사용하게 되면 해당 값의 타입을 구분해줄 수 있다.

	// 만약 넘겨받은 param이 왼값 참조라면 복사 형태로, 오른값 참조라면 이동 형태로 작동되어야한다.
	// std::forward를 이용하면 알아서 구분해준다.
	Test_copy(forward<T>(param));
	// 즉 전달 참조는 무조건 forward를 사용하면 된다는 그냥 공식처럼 외우기
}
// 근데 만약 매개변수에 const를 붙여주는 순간 전달 참조로 동작하지 않는다.
// const를 붙여주는 순간 바로 오른값 참조로 돌변하게 된다


int main()
{
	// 전달 참조
	// 전달 참조(Forwarding Reference)는 C++17 이전엔 보편 참조(Universal Reference)로도 불렸으며 오른값 참조와 비슷하게 생겼지만 
	// 형식 연역(Type Deduction)이 일어날 때 일어날 수 있는 값 전달 방식이다.형식 연역은 추론하여 타입을 정해주는 뜻이고, 
	// 이전에 앞서 배운 auto나 template 문법이 이에 해당된다.

	// 오른값 참조와 똑같이 앰퍼센트 두 개를 연달아 붙여 사용하지만 상황에 따라 왼값 참조, 오른값 참조 방식으로 나뉘게 된다.
	// 전달 참조는 보통 서버시간에 이 문법을 이용해서 장난을 칠거다

	Knight k1;
	Test_RvalueRef(move(k1)); // rvalue_cast, 기본생성자 출력

	// 왼값 참조로 되고있다.
	Test_ForwardingRef(k1); // 복사 생성자 출력
	// 오른값 참조를 받아주는 함수이니까 왼값을 넣었을때 에러가 떠야하는데 통과가 되는것을 볼수있다.
	// 오른값 참조
	Test_ForwardingRef(move(k1)); // 이동 생성자 출력

	// 왼값 참조
	auto&& k2 = k1; 
	// 왼값 참조가 되고있다.
	
	// 오른값 참조
	auto&& k3 = move(k1);

	// 보통 이런 상황은 템플릿이라거나 auto라는 문법으로 병행해서 사용할때만 등장한다
	// 공통점 : 형식 연역(Type Deduction)이 일어날 때 일어날 수 있는 값 전달 방식이다
	// 전달 참조는 특징적으로 그냥 우리가 만약에 왼쪽 값을 넣어 줬으면 왼쪽 참조로 얘가 작동이 되고 오른값을 넣어 줬으면 오른값 참조로 동작한다는 그냥 굉장히 편리한 아이입니다 

	// 전달 받을 때 받는 타입에 따라 왼값 참조인지 오른값 참조인지 추론해서 타입이 정해지게 되며 이러한 특징이 오른값 참조와 전달 참조의 차이를 나타낸다. 
	// 참고로 오른값과 오른값 참조는 다른 의미이다.

	// 지금까지는 전달 참조를 구별하는 방법
	// -------------------------------------
	// 그래가지고 왼값 참조랑 오른값 참조를 한 방에 두 개를 동시에 처리할 수 있게 되었다는 건 굉장히 아름다운데 두가지 케이스에 따라서 사용방법이 달라져야 되겠죠


	// 오른값 : 왼값이 아니다 = 단일식에서 벗어나면 사용 불가능한 것들
	// 오른값 참조 : 오른값만 참조할 수 있는 참조 타입
	Knight& k4 = k1;    // 왼값 참조
	Knight&& k5 = move(k1); // 오른값 참조

	//Test_RvalueRef(k5); // error
	//Test_RvalueRef(move(k5)); // 이러면 통과
	// 이 K5는 그러니까 결국에는 K5의 타입은 오른값 참조가 맞기는 하지만 K5 자체는 오른값이 아니라 왼값이라는 문제가 있는 거죠 
	// 그러기 때문에 K5를 또 여기다가 막바로 넣어줄 수가 없고 얘를 다시 요게 안에다가 넣어주기 위해서는 그럼 어떻게 해야 되느냐 
	// 다시 한번 요 std-move를 통해 가지고 요런 식으로 변환을 한번 해줘야 된다는 말이 되겠다

	Test_ForwardingRef(k5); // 복사 생성자 출력
	// 위의 코드에서 매개변수로 건넨 k5가 오른값 참조 타입을 가진다고 해서 오른값 참조가 되는 것은 아니다.
	// 타입이 오른값 참조일 뿐이고 오른값이 아닌 왼값이다.
	// 그래서 결과는 왼값 참조로 들어가게된다. 오른값 참조로 값을 전달하고 싶다면 move를 사용하여 캐스팅 해줘서 오른값을 추출해서 넘겨줘야한다

	Test_ForwardingRef(move(k5)); // 이동 생성자 출력
	// 여기서 move를 해줘서 오른값을 넣어줬다해도 Test_ForwardingRef 이 함수에서 Test_copy(move(param)); 이렇게 한번더 move를 해줘야지만 이동생성자가 호출이된다



	// 결국에는 이렇게 우리가 하나만 만들어 줬는데 경우에 따라 복사 방식으로 정답하기도 하고 어떤 경우에 따라 이동 방식으로 동작하는 그런 굉장히 아름다운 함수를 만들어 준 거고
	// 이게 가능했던 이유는 전달 참조라는 새로운 문법이 만들어졌기 때문이겠죠
	// 전달 참조는 결국에는 굉장히 특별하게도 이렇게 템플릿이랑 auto와 관련된 그런 추론이 일어나는 경우에 이렇게 활용할 수 있었다는 걸 알 수가 있었고 이 아이 자체는 왼값 혹은
	// 오른값 둘 다 일단 받아줄 수 있는 그런 굉장히 특이한 아이라고 했었습니다 그래서 그 값에 따라가지고 원본값이 왼쪽값 참조였는지 오른값 참조였는지
	// 따라가지고 다시 한번 이렇게 바꿔치기를 해주는 그 부분을 이제 forward를 그냥 사용하면 된다
	// 즉 전달 참조는 무조건 forward를 사용하면 된다는 그냥 공식처럼 외우기
}