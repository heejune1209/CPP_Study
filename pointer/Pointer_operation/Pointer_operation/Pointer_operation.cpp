#include <iostream>
using namespace std;

// 제 2장 : 포인터 연산

// 1) 주소 연산자 (&)
// 2) 산술 연산자 (+ -)
// 3) 간접 연산자 (*)
// 4) 간접 멤버 연산자 (->)

struct Player
{
	int hp; // +0
	int damage; // +4
};


int main()
{
	int number = 1;

	// 1) 주소 연산자 (&)
	// - 해당 변수의 주소를 알려주세요~
	// - 더 정확히 말하면 해당 변수 타입(type)에 따라서 TYPE* 변환
	int* Pointer = &number;

	// 2) 산술 연산자(+ -)

	number += 1; // 디버깅 해보니 1증가 했다

	// int*
	// - * : 포인터 타입이네! (8바이트) 주소를 담는 바구니!
	// - int : 주소를 따라가면 int(4바이트 정수형 바구니)가 있다고 가정해라!

	// 포인터에서 +나 -등 산술 연산으로 1을 더하거나 빼면,
	// 정말 '그 숫자'를 더하거나 빼라는 의미가 아니다.
	// 한번에 TYPE의 크기만큼을 이동해라!
	// 다음/이전 바구니로 이동하고 싶다 << [바구니 단위]의 이동으로
	// 즉, 1을 더하면 = 바구니 1개 이동시켜라
	// 3을 더하면 = 바구니 3개 이동시켜라

	Pointer += 1; // 디버깅 해보니 4(int의 크기) 증가 했다 
	// 즉, 여기서 바뀐건 number의 주소값이 Pointer += 1;이 코드를 실행하기전엔, 008ffcd0 이었다고 한다면,
	// 저 코드를 실행해서 연산이 되면, +4만큼 이동한 008ffcd4로 변화하는것을 볼수 있다.

	// 3) 간접 연산자 (*)
	// - 포탈을 타고 해당 주소로 슝- 이동
	*Pointer = 3; // : number = 3; 이 코드와 같은 내용이다.

	Player player;
	player.hp = 100;
	player.damage = 10;

	Player* playerPtr = &player;
	(*playerPtr).hp = 200; // player를 사용하는 것과 똑같다.
	// 위의 코드는 playerptr 바구니에 있던 주소로 뿅 이동을 한 다음에 
	// 거기다가 플러스 0 에 해당하는 주소에다가 200을 넣어 준 거라고 보면되고,
	(*playerPtr).damage = 200;
	// 여기 코드는 playerptr 바구니에 있던 주소로 뿅 이동을 한 다음에 거기다가 플러스 4 만큼을 앞으로 이동해가지고 
	// 거기다가 200을 넣어준 그런 부분이라고 보면된다.

	// 4) 간접 멤버 연산자 (->)
	// 이것은 *랑 .을 합한거라고 보면됨.
	// 사실 어셈블리 언어로 까보면 .은 사실상 그냥 덧셈.
	// -> 는 *와 . 을 한방에!

	playerPtr->hp = 200; // (*playerPtr).hp = 200; 이 코드랑 똑같음.
	playerPtr->damage = 200; // (*playerPtr).damage = 200; 이 코드랑 똑같음.


	return 0;

}