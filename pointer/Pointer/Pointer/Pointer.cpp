#include <iostream>
using namespace std;

// 제 1장 : 포인터
int main()
{
	// 지금까지 사용한 방식
	// number라는 이름의 4바이트 정수 타입의 바구니를 만든다.
	// number라는 변수 스택 메모리에 할당
	// number = 1라 함은, number 바구니에 1이라는 숫자를 넣으라는 의미.
	// 따라서 스택 메모리에 있는 특정 주소(number 바구니)에 우리가 원하는 값을 넣은 셈
	// number는 비유하자면 메모리에 이름을 붙인 것 (찰떡같이 알아들어서)
	// 나쁘지 않고 편리한데, 단점은 TEXTRPG 원본 수정
	// 하지만 지역 변수는 유효 범위가 있어서 언제 어디서는 접근할 수 없는 상황이 발생하고 경우에 따라서 딱 이 주소를
	// 접근해서 수정하고 싶은 상황도 생길 수 있다.
	// 그때 사용할수 있는 방법이 포인터라는 주소 바구니를 사용하는 것이다.
	int number = 1;

	// TYPE* 변수이름;
	// 일단 2가지 요소
	// - TYPE
	// - *
	// * 는 두가지 의미가 있는데 
	// 처음에 변수에서 만들어줄땐 주소를 저장하는 바구니라고 의미를 전달하는 기능을 하고
	// 두번째로는 변수 앞에다가 별표를 붙여 가지고 사용하게 될 경우에는 뭔가 워프를 해라, 진짜 주소로 이동해라 라는 의미가 된다.

		// 바구니는 바구니인데..
		// [주소를 저장하는 바구니다!]
		// 변수 선언할때 *가 등장했다 -> 포인터 = 주소
		// 참고로 x86이라고 하면 32비트 프로그램을 의미하는거기 때문에 주소 체계가 다 4바이트단위로 되어있다.
		// 또, 포인터라는 바구니는 32비트로 실행하고 있으면 4바이트 or 64비트로 구동될경우 8바이트가 고정크기이다. 
		// ptr은 주소를 저장하는 바구니(변수). 
	int* ptr = &number;


	// 근데 남의 주소를 갖고 뭘 하라는 거지?
	// 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 해라!
	// *변수이름 = 값;
	*ptr = 3;
	//* : 포탈을 타고 순간이동을 한다고 생각해보자.
	// *이 여러번 등장하니 헷갈리는데, 사용 시점에 따라서 구분해서 기억하자
	// - 변수 선언단계에서 * 가 등장하면 => (주소를 저장하는 바구니다!)
	// - 근데 실질적으로 그 변수를 사용할 때 *가 붙으면 => (포탈 타고 해당 주소로 순간이동)
	// 이게 한 단계 더 들어가 가지고 이 바구니의 내용물의 주소로 이동을 한 다음에 그 내용물을 다시 수정을 해 주라고 
	// 두 단계에 걸쳐 가지고 일단은 뭔가가 일어났다고 볼 수가 있다.
	// int* ptr = &number;으로 분석해볼때, 저장한 주소를 타고 가면 어떤 값이 있는지 그 값에 대한 타입은 
	// 저 int가 힌트를 주고 있다고 보면 된다. 즉 ptr은 해당 주소를 타고가면 정수가 있어요 라고 설명하고있음.
	// 그래서 그 주소에 가서 그 값을 긁어서 value1에다 똑같은 int에다가 넣어줄수 있던거고, 2라는 값을 넣어놨다 해도,
	// 2를 4바이트 정수로 인식해서 *ptr라는 이 메모리에다가 넣어준다.
	int value1 = *ptr;
	*ptr = 2; // 여기서 이렇게 2로 바꿔주면 number변수에 있는 값도 2로 바뀐다. 왜냐면 ptr은 number의 주소 값을 가지고있는 바구니이기때문에 ptr 에 *을 붙여서 접근한뒤 2로 바꿔줬다고 보면된다

	// TYPE은 왜 붙여줄까?
	// * = 포인터의 의미 = 주소를 저장하는 바구니 = 4 or 8바이트 고정크기

	// 주소에 가면 뭐가 있는데?
	// ex) 결혼식 청첩장에 있는 주소 = 예식장 주소
	// ex) 명함에 있는 주소 =  회사 주소
	// * = 포인터 (주소 담는 바구니)
	// 결국 이 타입을 넣어준 이유는 이 해당 주소에 갔을때 거기있는 데이터는 무엇무엇으로 분석을 해줘. 그것으로 판단.

	// 0b101010101111 이진수로 이런 데이터가 저장되어있었다고 했을때 얘를 정수로 볼것이냐, 문자로 볼것이냐,
	// 어떤 식으로 얘를 분석할 것인지 따라가지고 의미가 완전히 달라진다고 했다.
	// 심지어 메모리 기준으로 1바이트만 끊어서 볼 것인지, 2바이트로 볼것인지, 4바이트로 볼것인지 따라서 
	// 완전히 숫자가 달라질수도 있다는 얘기가 된다.
	// 즉, 그것을 정수인지 아니면 실수인지로 분석을 하는거에 따라 가지고 완전히 데이터가 인식이 달라질 수 있단 얘기.

	// 결국에는 이 포인터를 타고 갔을 때 무엇이 있느냐를 앞에 타입으로 나타낸다고 볼수 있다.
	//int* ptr2;

	// 타입의 불일치
	__int64* ptr2 = (__int64*)&number;

	*ptr2 = 0xAABBCCDDEEFF; // 6바이트
	// 디버깅을 해보면,
	// 설정했었던 타입의 바이트보다 초과된 2바이트가 밀려가지고 여기까지 지금 영역을 차지하고 있는 상황을 파악할수 있다
	// 즉, number라는 변수자체의 영역을 무시를 하고 멋대로 다른 영역까지 이렇게 쿨하게 지금 덮어 써가지고 사용하고있다
	// 이 부분은 경우에 따라서 그냥 아무런 상관이 없는 그런 메모리 주소였다고 하면 해프닝으로 끝날수 있는데,
	// 굉장히 중요한 데이터가 있었던 영역이라고 가정하면 프로그램 자체가 굉장히 묘하게 동작할 수 있다는 얘기가 된다.
	// C++의 무서운 점은 포인터를 이용해서 주소를 멋대로 조작할 수 있다보니까 이렇게 조금이라도 주소를 잘못 인식해서
	// 그 해당 주소로 넘어가서 사용하게 되면 데이터가 덮어 써지는 문제가 발생할 수 있다는게 굉장히 무서운 사실이 된다.
	return 0;
}
// 예시) 
void SetHP(int* hp)
{
	*hp = 100;
}

// [매개변수][RET][지역변수][hp 1]  [매개변수(주소)][RET][지역변수][hp 1]
//int main()
//{
//	int Hp = 1;
//	SetHP(&Hp);// = > 결과를 보면 hp가 100으로 세팅 되어있다.
//	//*hp = 100;
//}