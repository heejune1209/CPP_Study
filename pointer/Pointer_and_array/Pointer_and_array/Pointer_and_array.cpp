#include <iostream>
using namespace std;
// 제 6장 : 포인터 vs 배열

void Test(int a)
{
	a++;
}
// 배열은 함수 인자로 넘기면, 컴파일러가 알아서 포인터로 치환한다 (char[] -> char*)
// 즉 배열은 내용 전체를 넘긴게 아니라, 시작 주소(포인터)만 넘긴 것
void Test(char a[])
{
	a[0] = 'x';
}

int main()
{
	// 문자열 = 문자 배열
	// "Hello world";
	// .data 주소 [H][e][l][l][o][][W][o][r][l][d][\0]

	// test1[  주소  ] << 4 or 8바이트 => 문자열이 아무리 늘어나도 주소를 갖고 있는 바구니 자체의 크기는 변함없음. 
	// 주소안에 있는 데이터가 늘어나는것임.
	const char* test1 = "Hello World";   // 데이터 수정 불가능
	// test1은 그냥 주소값만 들고 있고 그 원격으로 실제 데이터는 원격 어딘가의 데이터 영역에 들어가 있는데 
	// 걔는 심지어 읽기 전용 데이터이기 때문에 얘가 const가 붙어가지고 주소 안에 있는 데이터를 아예 수정도 할 수 없는 상태가 됐다고 볼 수가 있겠습니다
	// test1[0] = 'R'; => 데이터 수정 불가.


	// .data 주소 [H][e][l][l][o][][W][o][r][l][d][\0]
	// [H][e][l][l][o][][W][o][r][l][d][\0] 12바이트 바구니들 => 문자열이 늘어나면 그만큼 test2의 크기도 커짐.
	// test2 = 시작 주소
	char test2[] = "Hello world";
	test2[0] = 'R'; // 데이터 수정 가능

	// 포인터는 [주소를 담는 바구니]
	// 배열은 [닭장] 즉, 그 자체로 같은 데이터끼리 붙어있는 '바구니 모음'
	// - 다만 [배열 이름]은 '바구니 모음'의 [시작 주소]
	그래서 문자열을 수정하고 싶다면 char msg[] = "Hello"; 이런식으로 배열에 저장해야하고,
		그냥 읽기 전용 데이터로 사용하고 싶다면 const char* 로 저장해야한다. (char* 로 저장하면 오류남)

		// 배열을 함수의 인자로 넘기게되면?

		int a = 0;
	// [매개변수][RET][지역변수(a=0)] [매개변수(a=0)][RET][지역변수]
	Test(a);
	cout << a << endl;

	// test2가 바뀔까? 안바뀔까? -> 바뀐다!
	Test(test2);
	cout << test2 << endl;

	/*char test3[1];
	test3 = test2;*/
	// 위의 코드가 에러가 나는 걸 우리가 지난번에 확인을 할 수 있었는데 애당초 얘는 어떤 바구니의 개념이 아니라 
	// 그냥 요 자체가 그냥 주소의 의미이기 때문에 요렇게 쿨하게 그냥 쉽게 쉽게 복사가 되지 않는다.
	// 바구니가 아니라 그냥 그 자체로 어떤 주소값을 나타내는 이름이라고 볼 수가 있는 거죠.

	// 그래서 배운 내용을 한 줄 요약하면은 포인터랑 배열은 엄연히 말해서 다른 개념이다. 
	// 비록 배열의 이름 자체가 이렇게 포인터로 쉽게 변환이 되고 그리고 시작 주소를 의미한다고는 하되 
	// 실질적으로 메모리 상에서 지금 포인터와 배열이 어떻게 만들어지는지 차이를 유심히 보면은 
	// 포인터는 그 자체로 하나의 별도의 바구니가 생성이 되는데 
	// 그 바구니의 주소에 뭔가가 다른 영역을 가리키고 있는 상태로 이렇게 만들어지는 거였고 
	// 그게 아니라 배열로 이렇게 만들어 줬다고 하면은 배열은 별도의 바구니가 뭔가가 생성되는 그런 느낌이 아니고 그냥 이름 자체가 
	// 주소의 의미를 지녔을 뿐 실질적으로 본체 자체는 그냥 이렇게 어마어마하게 큰 거 그 자체, 
	// 배열 그 자체가 만들어진다고 봐야 된다는 얘기가 되는 거죠.
	// 마지막으로 배열을 함수 인자로 넘기면, 얘는 포인터 즉 자기 자신의 시작 주소로 이렇게 넘겨 가지고 시작이 된다 
	// 따라서 뭐 사실상 배열로 넘긴거나 이렇게 포인터로 넘긴거나 별반 차이가 없다는 걸 볼 수 있다.

	return 0;
}
