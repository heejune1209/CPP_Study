#include <iostream>
using namespace std;


// 포인터 마무리

// 1) 포인터 vs 배열 2탄
// 2) 주의사항 (마음가짐)

int& TestRef()
{
	int a = 1;
	return a;
}

int* TestPointer()
{
	int a = 1;
	return &a;
}
// 조금이라도 더 간편하고 메모리를 덜 사용하기 위해 반환값을 참조하거나 포인터로 내보내는 경우 아주 위험하다.
// 위처럼 함수를 작성하고 main 함수에서 TestPointer();를 사용하여 포인터의 주소값을 넘겨받았다고 가정해보자.

void TestWrong(int* ptr)
{
	int a[100] = {};
	a[99] = 0xAAAAAAAA; // 디버깅 편하게 하기 위해
	*ptr = 0x12341234;
}
// 디버깅해보면 a[99]의 값이 aaaaaaaa로 잘 들어가 있는 것을 확인할 수 있고,
// 여기서 F10을 눌러 한 줄씩 실행시키면 바로 다음 주소에 12341234 값이 들어간 것을 알 수 있다.
// 그리고 한 번 더 F10을 눌러 한 줄을 실행시키면 함수를 빠져나오는 순간 예외가 발생하게된다. 참고로 이건 컴파일러가 알아서 버그를 잡아주는 부분에서 걸린 버그이고 
// 결론은 유효 범위를 벗어난 포인터의 값을 건드려서 나는 에러이다.
// 해당 주소가 활성화된 스택 프레임 내에 있는지 아닌지, 값을 덮어씌우는 곳에
// ebp, ret 주소같이 중요한 정보가 담겨있는지, 디버깅 모드에서 오버플로우 여부를 탐지하고 있던 장소인지 
// 모두 중요한 포인트를 잡게 되는데 이렇게 유효하지 않은 범위에 있는 주소값을 가리키게 되면 메모리 오염이 되는 것이다. 
// 그러니 포인터를 사용하거나 참조를 사용할 땐 항상 조심해야 한다.
// 그리고 어지간해서는 이렇게 스택에다가 스택과 관련된 데이터의 주소를 이렇게 밖으로 넘겨주는 행동은 
// 당연히 조심해야 됩니다
// 그래서 이 함수의 생명 주기를 잘 생각해 가지고 여기 안에만 유효한 값에다가 
// 그런 주소값을 외부로 넘겨주는 행위는 절대로 하면 안 된다는 걸 하나를 기억을 해주시면 되겠습니다 

// 잘못된 포인터와 메모리 오염(TestWrong 함수)
// 문제의 원인
// ptr은 TestPointer에서 반환된 유효하지 않은 포인터를 전달받습니다.
// * ptr = 0x12341234; 를 실행하면, 이 포인터가 가리키는 잘못된 메모리 주소에 값을 쓰게 되어 메모리 오염이 발생합니다.

// 메모리 오염의 결과
// 1. 스택 메모리 오염:
// TestWrong 함수의 스택 메모리 공간에 있는 a 배열과 연관된 데이터가 덮어쓰기될 수 있습니다.
// 이는 프로그램의 예상치 못한 동작을 유발하며, 심각한 경우 프로그램이 충돌하거나 비정상적으로 종료됩니다.

// 2. 힙 메모리 오염 가능성:
// 만약 ptr이 해제된 힙 메모리 영역을 가리키고 있었다면, 힙 메모리를 손상시킬 가능성도 있습니다.이는 이후 동적 메모리 할당 시 충돌로 이어질 수 있습니다.

// 포인터 반환과 사용 시의 위험성 및 해결 방법
// 위험성 1: 로컬 변수의 주소 반환
// 함수에서 스택에 저장된 로컬 변수의 주소를 반환하면, 이 메모리는 함수 종료 후 더 이상 유효하지 않습니다. 
// 이를 사용하는 코드는 항상 정의되지 않은 동작으로 이어질 위험이 있습니다.

// 해결 방법:
// 1. 정적 변수 사용: 로컬 변수를 정적(static) 변수로 선언하면, 이 변수는 스택 대신 데이터 영역에 저장되므로 함수 종료 후에도 유효합니다.
// 2. 동적 메모리 할당: 힙 메모리를 할당하여 변수의 수명을 제어합니다.
// ex) 

int* TestPointer2()
{
	int* a = new int(1); // 힙 메모리 할당, a를 1로 초기화
	return a;
}

//int main()
//{
//	int* pointer = TestPointer();
//	*pointer = 123;
//	delete pointer; // 메모리 해제
//}


// 3. 값 복사 : 값을 반환하거나 참조를 사용하여 안전하게 전달합니다.
// 근데 이건 좋지 않은 방식

// ------------------------------------------------------------------
// 위험성 2: 잘못된 포인터 전달
// 유효하지 않은 포인터를 전달받아 사용하면, 다른 메모리 영역을 침범하여 데이터를 손상시키고, 프로그램의 안정성을 위협합니다.

// 해결방법:
// 1. 포인터 유효성 확인: 포인터가 올바른 메모리 주소를 가리키는지 확인합니다.
// ex)
/*
void TestWrong(int* ptr)
{
	if (ptr == nullptr)
	{
		std::cerr << "Invalid pointer!" << std::endl;
		return;
	}
	*ptr = 0x12341234;
}
*/

// 2. 참조 전달 사용: 포인터 대신 참조를 사용하여 의도치 않은 잘못된 포인터 사용을 방지합니다
// 하지만 유효한 주소를 받아온다면 포인터를 사용해도 안전하다(크래시가 나지 않는다)

void TestWrong2(int& ref)
{
	ref = 0x12341234;
}// 크래시가 안남

// 왜 참조는 안전하고, 포인터는 크래시 가능성이 있을까?
// 참조(int&):
// 참조는 한 번 생성되면 항상 유효한 변수(혹은 메모리)를 가리킵니다.
// 참조가 가리키는 대상을 임의로 바꿀 수 없기 때문에 안전합니다.

// 포인터(int*) :
// 포인터는 주소값을 임의로 변경할 수 있기 때문에, 유효하지 않은 메모리 주소를 가리킬 가능성이 있습니다.
// 예를 들어, 유효하지 않는 주소가 아니라면 이후 해당 메모리를 사용하려 할 때 크래시가 발생합니다.


//int main()
//{
//	int value = 1;
//	TestWrong(value); // 안전하게 값 수정
//}

// 포인터 유효성 확인, 참조 사용, 스마트 포인터 활용 등의 방법으로 잘못된 포인터 사용에 대한 안정성을 확보하세요.

int main()
{
	// 주소를 담는 바구니
	// 진퉁은 저~ 멀리 어딘가에 있음
	// P는 단지 그곳으로 워프하는 포탈
	int* p;

	// 진짜 배기! 원조 데이터
	// 닭장처럼 데이터의 묶음 (엄청 많고 거대하다는 인식을 받아야함)
	int arr[10] = { 1,2,3,4,5,6,7,8 };

	// 그런데 상당히 많은 사람들이 [배열 = 포인터]라 착각하는 경향이 있음!

	// -[배열의 이름]은 배열의 시작 주소값을 가리키는 type*포인터로 변환 가능!
	// 그래서 이렇게 저장이 가능!
	p = arr;

	//- [TYPE형 1차원 배열]과 [TYPE형 1차원 포인터]는 완전히 문법적으로 호환이 된다 
	cout << p[0] << endl;
	cout << arr[0] << endl;
	cout << p[5] << endl;
	cout << arr[5] << endl;

	cout << *p << endl; // p[0]
	cout << *arr << endl; // arr[0]
	cout << *(p + 3) << endl;
	cout << *(arr + 3) << endl;

	// 2차원 배열 vs 다중 포인터

	// [1][2][3][4]
	int arr2[2][2] = { {1,2},{3,4} };

	// 주소2[] << 4바이트 바구니
	// 주소1[주소2]
	// pp[주소1]
	// int** pp = arr2; // 호환 불가
	// int** pp = (int**) arr2; // 변환 안됨

	// 변환이 안되는 이유는 디버깅을 하면 구조가 이렇게 있다는것을 알수 있는데 주소1을 타고가면 1이라는 숫자가 있는 상태이고
	// 1번이라는 주소로 순간이동을 하려고 하는데 1번이라는 주소는 유효하지 않은 엉뚱한 주소이다 보니까 
	// 프로그램이 크래시가 남.
	// 결국에는 2차원 배열과 다중 포인터는 서로 호환이 전혀 되지 않는 타입이라는 걸 알 수가 있다
	// 주소2[] << 4바이트 바구니
	// 주소1[00000001] 이렇게 
	// pp[주소1]
	// 그러면 어떻게 해야하냐면 주소 1로 한번 타고 이동하는것 까지는 그럴싸 한데, 그 안에 있는 다른 주소로 다시한번 워프
	// 를 하는 게 아니다 보니까 애당초 이렇게 포인터를 두개 연속으로 해서 사용하면 안된다는 얘기가된다
	// int* pp = (int*)arr2; 이렇게 하나로 멈췄어야했고 어떻게든 데이터를 꺼내서 쓸수있는 방법을 강구해야된다는 얘기가
	// 된다

	// int* pp = arr2;

	// TYPE name[개수]

	// 배열에 대한 포인터
	// [1][2] [3][4]
	// [주소]
	int(*p2)[2] = arr2;
	cout << (*p2)[0] << endl; // 1
	cout << (*p2)[1] << endl; // 2
	cout << (*(p2 + 1)[0]) << endl; // 3
	cout << (*(p2 + 1)[1]) << endl; // 4

	cout << p2[0][0] << endl; // 1
	cout << p2[0][1] << endl; // 2
	cout << p2[1][0] << endl; // 3
	cout << p2[1][1] << endl; // 4

	// 둘의 의미는 서로 똑같다
	// 실제로는 요런 문법까지는 당연히 기억을 할 필요가 없어요
	// 포인터로 했더니 터졌다라는 연습을 하고 있었으니까 그에 대한 해답을 알려드리기 위해서 얘를 그냥 간단하게 실습한것
	// 너무 어렵다 싶으면 여기까지 다룬 내용은 그냥 잊어도됨
	// 인생에는 거의 대부분 이랗게 1차원 배열과 1차 포인터만 사용하게 될것임
	// 다만 2차원 배열이라고 하면 걔를 멋대로 다중 포인터로 변환하는건 굉장히 위험하다 사실 그러면 안된다를 얘기하고있음


	//cout << (**pp) << endl;
	// --------------------------------------------------------------------------------------------------------------
	// C++의 가장 무서운 점은 알게 모르게 프로그램이 크래시 나지는 않지만 메모리를 엉뚱하게 오염시켜 가지고 
	// 이제 데이터가 다 오염이 돼서 이상하게 작동하는 순간 그때서야 진짜 이제 문제가 심각해짐
	// 왜냐면 나중에 어떤 나비 효과를 인해 가지고 엉뚱한 메모리를 조작한 애가 바로 터지지 않고
	// 한 일주일 후에 엉뚱한 곳에 가 가지고 이제 크래시가 나게 되면 절대로 왜 크래시가 났는지 원인을 찾을 수가 없게 됩니다

	// 1) [매개변수][RET][지역변수][매개변수][RET][지역변수(a)]
	// 2) [매개변수][RET][지역변수]
	int* pointer = TestPointer();// => int* pointer = a(TestPointer의 스택메모리에 있는 변수)
	// 근데 여기서 TestPointer함수가 끝나면 a가 유지되지 않고 함수 종료와 동시에 사라지기 때문에
	// pointer가 가리키고 있는 a의 주소는 더이상 날라가고 유효하지 않는 주소를 가리키게 된다.
	// 그리고 그 유효하지 않는 주소를 통해 데이터를 쓰려고 하면 당연히 크래시가 난다.
	cout << *pointer << endl;
	*pointer = 123;
	// 그냥 여기서 실행을 해봐도 그냥 아무런 문제가 없이 실행이 되는 것을 볼수 있다 사실은
	// 엉뚱한 메모리를 우리가 건드리고 있는 것임에도 불구하고 여기 어딘가에 있는 메모리를 우리가 
	// 지금 여기서 건드리는 거에도 불구하고 지금 아무런 크래시가 나지 않은 걸 볼 수가 있는것이다. 이런 상황이 상당히 
	// 무섭다

	TestWrong(pointer); // 305402420 으로 바뀜
	cout << *pointer << endl; 

	int value = 1;
	TestWrong2(value); // 305402420 으로 바뀜
	cout << value << endl; 

	int* pointer2 = TestPointer2();
	*pointer2 = 123;
	delete pointer2; // 메모리 해제

	return 0;
}
//---------------------------------------- -
//Pet pet;
//
//// Archer를 만들 때 pet 정보도 넘겨준다
//p = new Archer(&pet);
//
//이렇게 스택에 있는 메모리를 이리저리 쿨하게 넘겨주는 것은 굉장히 위험한 작업이다