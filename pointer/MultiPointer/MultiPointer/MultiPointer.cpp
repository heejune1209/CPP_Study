#include <iostream>
using namespace std;


void SetMessage(const char* a)
{
	a = "Bye";
	// 실행 하면 바뀌지 않는것을 볼수 있다. 왜냐면 데이터를 수정하기 위해서는 
	//그 해당 주소로 이렇게 순간 이동을 해 가지고 얘를 건드려야, 실질적으로 원본 데이터를 건드리는 거지, 
	// 위 코드는 뭐 그냥 그 바구니 주소를 담는 바구니에 있는 주소값을 그냥 우리가 멋대로 수정한 셈에 불과합니다
	// 사실상 수정하고 싶다고 했으면 아래 처럼 코드를 작성했어야했음.(근데 const라서 수정안됨)
	//*a = 'B';
	//*(a + 1) = 'y';
	// a[0] = 'B';
	// a[1] = 'y'; 이렇게 해도 위의 코드와 똑같은 의미이다
	// *(a+1) = a[1];
}

void SetMessage(const char** a)
{
	*a = "Byeee";
}

// 아래 함수 코드에서 포인터 재지정은 가능하지만, 실제 문자열 데이터를 수정하려는 경우에는 작동하지 않습니다.
// 예를 들어, 아래 코드는 잘못된 접근입니다 :
void ModifyString(char** a)
{
	(*a)[0] = 'B'; // 문자열 리터럴을 직접 수정하려고 시도
}
void SetMessage2(const char*& a)
{
	a = "Wow";
	// 참조에도 *에다가 &(참조)를 붙일수 있다
	// 다중 포인터처럼 똑같이 분석
	// 참조가 붙었다는건 그 해당 변수에다가 다른 닉네임을 붙여서 똑같은 원본을 건드리겠다라는 의미
}

int main()
{
	// Hello라는 데이터는 정확히는 .rodata 에 있다. 
	// .rodata Hello주소[H][e][l][l][0][\0]
	// .rodata Bye주소[B][y][e][\0]


	// msg[ Hello주소 ] << 4 or 8바이트 고정크기
	const char* msg = "Hello";
	// *msg = "x"; // error
	// 스택 프레임 순서
	// 1) 
	// 2) [매개변수][RET][지역변수(msg(Hello주소))][매개변수(a(Bye주소))][RET][지역변수]
	// 3) [매개변수][RET][지역변수(msg(Hello주소))]
	// 즉, 애당초 이 stack frame 내에서 우리가 매개변수에다가 넣어준 그 바구니의 내용물을 실컷 고치고 있던 셈이다.
	// 실질적으로 바꾸고 싶었던 이 지역변수에 있는 이것을 건드리지 못했기 때문에 쓸모없는 행동을 했다고 볼수 있다.
	SetMessage(msg); // const char* a
	cout << msg << endl; // "Hello" 출력

	SetMessage(&msg); // 매개변수 : const char** a 
	cout << msg << endl; // "Byeee" 출력
	// 이 코드는 문자열 리터럴 "Hello"를 수정하려는 것이 아니며, msg라는 포인터가 새로운 문자열 리터럴 "Byeee"를 가리키도록 재지정한 것입니다.
	// 다중 포인터를 사용함으로써 함수 내의 a는 Hello의 주소를 담는 대신 &msg. 즉, Hello의 시작 주소를 담고 있는 msg의 주소를 담게 된다.
	// 함수 스택 프레임 내의 매개 변수에서도 msg로의 접근이 가능하게 되면서 Hello라는 값도 직접 건드릴 수 있게 되는 것이다. 주소의 주소를 담는다고 생각하면 이해가 쉽다.
	// 이 코드는 "Hello" 문자열 리터럴을 직접 수정하지 않기 때문에 안전하게 작동합니다.
	// 그러나 const char* msg가 아닌 읽기 전용 데이터를 직접 수정하려고 하면 정의되지 않은 동작(UB)이 발생합니다.

	//ModifyString((char**)&msg); // 강제 캐스팅 (위험!) 크래시가 난다
	//cout << msg << endl;        // undefined behavior
	// 왜 크래시가 났냐면 "Hello" 문자열 리터럴은 읽기 전용 메모리에 저장됩니다.
	// 따라서(*a)[0] = 'B'; 로 데이터를 수정하려는 시도는 정의되지 않은 동작을 초래합니다.

	// 결론은 이 코드에서는 const char* 포인터를 재지정하여 새로운 문자열 리터럴을 가리키도록 했기 때문에 작동합니다.
	// 그러나 문자열 리터럴 자체를 수정하려는 시도는 항상 정의되지 않은 동작입니다.
	// 문자열 데이터를 실제로 수정하려면 쓰기 가능한 메모리(char[] 배열 또는 동적 할당)를 사용해야 합니다.

	// 3) Hello주소를 타고가면 이런 느낌으로 되어있다..rodata Hello주소[H][e][l][l][0][\0]
	// 2) msg[ Hello주소 ] << 4 or 8바이트 고정크기
	// 1) pp[ &msg ] << 4 or 8바이트 고정크기
	const char** pp = &msg;

	// [매개변수][RET][지역변수(msg(Hello주소))][매개변수(a(&msg msg의 주소))][RET][지역변수]
	SetMessage(pp);
	// 아무 주소나 아무거나 넣어줄 수는 없는 거고 반드시 걔를 타고 가서 보면은 
	// 즉 타고 간다는 게 이 별 하나를 까는 느낌이 되는 거니까 그 안에 내용물은 무조건 콘셉트 캐릭터 포인터가 
	// 돼야 된다는 건 당연히 이제 일치해야 된다는 얘기가 되겠습니다
	*pp = "Bye"; // pp에 *을 타고 가면 Hello주소가 있는걸 알수 있다
	cout << msg << endl;
	// 드디어 msg의 내용물이 바뀐것을 볼수 있다.

	// 다중 포인터 : 뭔가 혼동스럽다?
	// 포인터는 그냥 양파까기라고 생각
	// ** 이렇게 있을때 순간이동을 할때는 항상 오른쪽부터 왼쪽으로 분석하면된다.
	// *을 하나씩 까면서 타고간다고 생각

	// [매개변수][RET][지역변수(msg(Hello주소))][매개변수(a(&msg msg의 주소))][RET][지역변수]
	SetMessage2(msg);
	cout << msg << endl;
	return 0;
}