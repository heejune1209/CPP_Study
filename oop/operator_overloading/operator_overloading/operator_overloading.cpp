#include <iostream>
using namespace std;

// 연산자 오버로딩(operator overloading)

// 연산자 vs 함수
// - 연산자는 피연산자의 개수/타입이 고정되어 있음

// 일반적인 변수들을 더하고 싶을 땐 + 기호를 사용하면 문제없이 잘 더해지지만 클래스 타입인 경우 문제가 생기게 된다.
// 그럼 클래스 타입인 경우는 어떻게 해야할까?
// 이때는 연산자 오버로딩으로 해결할수 있다
// 연산자 오버로딩으로 객체를 일반 변수들의 연산처럼 연산할수 있다

// 연산자 오버로딩?
// 일단 [연산자 함수]를 정의해야함
// 함수도 멤버함수 vs 전역함수가 존재하는 것처럼, 연산자 함수도 연산자 함수도 멤버 연산자 함수와 전역 연산자 함수로 만들 수 있다.

// 멤버 연산자 함수 version
// -- a op b 형태에서 왼쪽으로 기준으로 실행됨 (a가 클래스여야 가능, a를 '기준 피연산자'라고 함)
// ex) Position pos4 = pos3 + 1; => 만약 Position pos4 = 1 + pos3; 이면 에러(근데 전역 연산자 함수를 선언해주면 사용가능해짐)
// -- 한계) a가 클래스가 아니면 사용 못함

// -- 전역 연산자 함수 version
// -- a op b 형태라면, a, b 모두를 연산자 함수의 피연산자로 만들어 준다. 그래서 멤버 연산자 함수와는 다르게 순서가 상관없다.
// -- 멤버 연산자 함수와 달리 왼쪽(a)이 클래스가 아니라고 하더라도 사용가능

// 그럼 무엇이 더 좋은가? 그런거 없음, 심지어 둘중 하나만 지원하는 경우도 있기 때문
// - 대표적으로 대입연산자(a=b)는 전역 연산자 버전으로는 못만든다
// 전역으로 풀어주게되면 왼쪽 값이 오른쪽으로 대입될 수도 있는 위험한 상황이 발생하기 때문에 막아둔 것이다.
// 그래서 반드시 왼쪽에만 우리가 원하는 클래스가 등장하고 오른쪽엔 그냥 다른 아이가 등장하게끔 만들어줘야 한다는것을 볼수 있다.
// 그래서 반드시 대입연산자와 같은 것들은 멤버 연산자 함수 버전으로 만들어줘야 된다

// 복사 대입 연산자
// - 대입 연산자가 나온 김에 [복사 대입 연산자]에 대해 알아보자
// 용어가 좀 헷갈린다 [복사 생성자] [대입 연산자] [복사 대입 연산자]
// - 복사 대입 연산자 = 대입 연산자 중, 자기 자신의 참조 타입을 인자로 받는 것

// 기타
// 모든 연산자를 오버로딩 할 수 있는 것은 아니다. (::, ., .* 이런 건 오버로딩이 불가능하다.)
// 모든 연산자가 2개 항이 있는 것은 아니다. (증감 연산자 ++, --가 대표적인 단항 연산자이다.)
// 전위(++n)와 후위(n++)
// 전위형 : operator++()
// 후위형 : operator++(int)

class Position
{
public:
    // 멤버 함수
    /*void Test()
    {

    }*/

    // 연산자 함수
    // [반환 타입] operator[오버로딩하기 원하는 연산자]([매개 변수])
    // 멤버 연산자 함수
    Position operator+(const Position& arg)
    {
        Position pos;
        pos._x = _x + arg._x;
        pos._y = _y + arg._y;
        return pos;
    }
    Position operator+(int arg)
    {
        Position pos;
        pos._x = _x + arg;
        pos._y = _y + arg;
        return pos;
    }

    bool operator==(const Position& arg)
    {
        return _x == arg._x && _y == arg._y;
    }
    /*
    void operator=(int arg) // 반환타입이 void인 대입연산자의 멤버 연산자 함수
    {
        _x = arg;
        _y = arg;
    }*/
    Position& operator=(int arg) // 반환타입이 void가 아니라 자기 자신의 참조값을 뱉어주는 형태로 만드는 경우가 많음
    {
        _x = arg;
        _y = arg;

        return *this;
        // this는 자기자신을 가리키고 있는 포인터이다
        // Position* this = 내자신의 주소;
    }
    // [복사 생성자] [복사 대입 연산자]등 특별 대우를 받는 이유는,
    // 말 그대로 객체가 '복사' 되길 원하는 특징 때문
    // 동적 할당 시간에 더 자세히 알아 볼것
    // 그래서 복사 생성자 같은 경우도 따로 정의해주지 않으면 컴파일러가 자동으로 생성해주기 때문에 일반적인 복사는 가능하다.
    // 복사 대입 연산자는 말 그대로, 복사해서 대입해준다는 의미이다.
    // 참조 타입을 인자로 받는 경우엔 대부분 const를 붙여주는 게 좋다.

    // 복사 대입 연산자 
    // Position& operator=(const Position& arg) 이 함수에서 참조값을 받아줄때 const를 붙여줘야 pos5 = pos3++; 이 코드에서 에러가 안난다
    Position& operator=(const Position& arg)
    {
        _x = arg._x;
        _y = arg._y;

        return *this;

        // Position* this = 내자신의 주소;
    }

    // 전위형
    Position& operator++()
    {
        _x++;
        _y++;
        return *this;
    }
    //전위형 ++ 연산자는 객체를 증가시키고, 증가된 객체를 반환해야 합니다.
    //    이 연산은 객체 자신의 상태를 변화시키기 때문에 추가적인 인수를 필요로 하지 않습니다.
    //    ex) Iterator& operator++()
    //{
    //    // 내부 상태를 직접 수정
    //    this->current += 1;  // 예시: current는 현재 위치를 나타낸다고 가정
    //    return *this;        // 증가된 자신을 반환
    //}

    //전위형 ++ 연산은 증가된 객체를 그대로 반환합니다.
    //    참조를 반환하면 불필요한 복사를 방지할 수 있어 성능이 향상됩니다.
    //    이렇게 하면 연속적인 ++ 연산도 가능해집니다 :
    //ex)　＋＋（＋＋ａ）；
    // 후위형
    /*void operator++(int)
    {
        _x++;
        _y++;
    }*/
    //    int 매개변수의 의미 :
    //● 후위형 ++은 문법적으로 전위형과 구별되어야 합니다.
    //    ● C++에서는 후위형 ++ 연산자를 구분하기 위해 더미 매개변수 int를 사용합니다.
    //    ● 이 매개변수는 단순히 구별 목적으로 존재하며, 실제로 연산에 사용되지 않습니다.
    //    // 후위형 예시
    //    ex) Iterator operator++(int)
    //{
    //    Iterator temp = *this; // 현재 상태의 복사본 저장
    //    this->current += 1;    // 내부 상태 증가
    //    return temp;           // 증가 전의 복사본 반환
    //}
    //복사값을 반환하는 이유 :
    //● 후위형 ++ 연산자는 증가 이전의 객체 상태를 반환해야 합니다.
    //    ● 이를 위해 현재 객체를 복사한 뒤, 원본 객체를 증가시키고, 복사본을 반환합니다.
    //    ● 복사본을 반환해야 하므로 참조값을 반환할 수 없습니다(참조는 원본 객체의 변경된 상태를 가리키기 때문입니다).

        // 전위형은 계산이 끝난 후 자기 자신을 반환해야 연속으로 계산이 가능하다. 
        // 반대로 후위형은 현재 자기 자신의 값을 반환하고 세미콜론(;)을 지난 다음 바뀐 값이 적용되기 때문에 연속으로 계산이 불가능하다. 
        // 이러한 점을 살려 전위형은 참조값을 반환하고, 후위형은 값만 변화시켰다.

        // 후위형
        Position operator++(int)
    {
        Position ret = *this;
        _x++;
        _y++;
        return ret;
    }
    // 이렇게 해서 후위형의 반환값을 복사값으로 바꿔서 넘기게 되면 이제 값은 존재한다. 하지만 여전히 타입은 일치하지 않는다.

    /*효율성 측면 :
    ● 전위형은 참조값을 반환하므로 더 효율적입니다.
    ● 후위형은 객체 복사가 필요하므로, 추가적인 비용이 발생합니다.*/

        // (pos5 = pos3++;) => 에러
        // pos5는 Position&을, pos3++은 Position을 넘겨주기 때문이다.
        // 여기서 pos5가 값을 전달 받기 위해서는 참조값으로 받는 매개 변수(인자) 앞에 const를 붙여주어 받게 되면 에러를 해결할 수 있다.

        // 그리고 반환 타입에 &를 붙이는거랑 아닌거랑 완전히 다른얘기가된다고 했었다
        // 붙이면 실제 스택 메모리에 있는 이 return이라는 바구니의 주소값을 전달해주는 느낌이 되는건데 이거는 큰일 나는 일이라고 했었다
        // 왜냐면 애당초 이 return이라는 것 자체가 함수 범위 안에서만 유효하기 때문에 이렇게 하면 큰일나는거고
        // 참조값을 없애게 되면 return이랑 똑같은 값을 잘 복사해서 결과물을 전달해 주겠다라는 의미가 된다



public:
    int _x;
    int _y;
};

// 전역 함수
//void Test2()
//{
//
//}

//void operator=(const Position& a, int b)
//{
//    a._x = b;
//    b._y = b;
//} //전역으로 만들어주면 에러가 남

// 전역 연산자 함수
Position operator+(int a, const Position& b)
{
    Position ret;
    ret._x = b._x + a;
    ret._y = b._y + a;
    return ret;

    // 전역 연산자 함수를 위처럼 선언해주면 Position pos4 = 1 + pos3;도 사용 가능하다.
}


int main()
{
    int a = 1;
    int b = 2;
    int c = ++(++a);

    Position pos;
    pos._x = 0;
    pos._y = 0;

    Position pos2;
    pos2._x = 1;
    pos2._y = 1;

    Position pos3 = pos + pos2;     // error
    // 이러한 연산을 허용해주기 위해 연산자 함수를 사용하여 연산자 오버로딩을 해줘야 한다.
    // pos3 = pos.operator+(pos2)와 같은 의미
    // Position operator+(const Position& arg) 로 멤버 함수를 만들어줘서 실행이 가능
    // pos2를 매개변수로 받아줘서 실행하고 있음

    Position pos4 = pos3 + 1;
    // Position operator+(int arg) 로 멤버 함수를 만들어 줘서 실행이 가능
    // 정수 1을 매개변수로 받아줘서 실행하고 있음

    // 여기서 pos4 구문의 순서를 Position pos4 = 1 + pos3; 이렇게 반대로 하여 연산을 하면 에러가 나게된다. 
    // 전역 연산자 함수를 선언해주면 Position pos4 = 1 + pos3;도 사용 가능하다.
    // (Position operator+(int a, const Position& b)이라는 전역 연산자 함수를 선언해서 저위의 코드를 실행 할수 있다)


    bool isSame = (pos3 == pos4);
    // 양쪽이 다 클래스 형태라서 멤버연산자 함수로도 할수 있고, 전역 연산자 함수로도 실행이 가능하다
    // 멤버 연산자 함수 : bool operator==(const Position& arg)

    Position pos5;
    pos5 = 5;
    // Position pos5 = 5 와는 다른 의미

    pos3 = (pos5 = 5); // this를 이용해서 했더니 된다.
    // 대입 연산자의 경우 연속으로 사용할 수 있다. 하지만 연산자 함수 중복 정의 시 반환 타입을 void로 지정하게 되면 연속으로 사용할 수 없게된다. 
    // 대입 연산자를 연속으로 사용하고 싶으면 Position& operator=(int arg) 이렇게 자기 자신의 참조값을 뱉어주는 형태로 만들고, 자기 자신(this)을 반환값으로 지정해주면 된다.

    // 증감 연산자와 대입 연산자를 동시에 사용해보자.
    pos5 = pos3++;
    // 증감 연산자를 한 번 실행하고 대입 연산자를 실행하는 구문이다. 
    // 하지만 후위형은 반환값이 없으므로 해당 구문에서 대입 연산 시 에러가 나게된다.
    // pos5는 복사 대입 연산자의 기준 피연산자로 자기 자신의 참조값을 반환 타입으로 받고 있지만 pos3++은 반환값이 없기 때문이다.

    // 복사 대입 연산자라는 거에서 꼭 const를 붙여야 한다는 강제사항은 없지만, 이렇게 임시객체를 참조하지 못하는 문제 때문에 콘스트를
    // 붙여주게 되면 이 코드가 정상적으로 실행이 된다

    // 중요한건 타입이 일치하지 않음에도 불구하고 참조값에 const를 붙이게 되면 포지션의 복사값을 어떻게든 우여곡절 끝에 넘겨받을수 있었다는
    // 특징을 기억


    ++(++pos3);
    /*pos3++;
    ++pos3;*/


    return 0;
}