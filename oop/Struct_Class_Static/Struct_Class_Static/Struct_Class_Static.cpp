#include <iostream>
using namespace std;

// 객체 지향 마무리

// 1) Struct vs Class

// C++ 에서는 Struct 나 Class나 종이 한장 차이이다.
// 접근 지정자를 설정해주지 않으면 구조체는 public, 클래스는 private이 기본으로 설정되는 차이 말고는 없다.
// 왜 이렇게 했을까? C++은 C언어에서 파생되어 발전했기 때문에, 호환성을 지키기위함.
// -> struct은 그냥 구조체(데이터 묶음)을 표현하는 용도
// -> class는 객체 지향 프로그래밍의 특징을 나타내는 용도
struct TestStruct
{

    int _a;
    int _b;


};
// 2) Static 변수 , Static 함수 (Static = 정적 = 고정된)\
// 딱 하나만 존재해야하는 변수나 함수가 있다고 하면 static을 사용함
// Static은 정적, 고정된이라는 뜻을 가지는 단어이다. 해당 문법을 변수나 함수 앞에 붙여서 사용할 수 있는데, 
// 그렇게되면 스택 메모리에 올라가지 않는다.

// 초기화를 하면.data영역, 하지 않으면.bss 영역에 올라가게 된다.

// 마린이라는 클래스가 하나 있다고 가정해보자. 기존 _attack이라는 변수는 마린의 공격력을 의미하고 있다. 
// 하지만 마린의 공격력은 각 객체마다 다른 게 아닌, 마린이라는 클래스 자체와 연관이 되어있는 데이터이다. 
// 만약 마린의 공격력을 변경해야 한다면 생성된 마린 객체 수만큼 공격력을 바꿔줘야 할 것이다.

// 이러한 점을 보완하기 위해 정적 변수를 사용한다.
// 정적 변수를 사용하게 되면 s_attack이라는 변수는 스택 메모리가 아닌 다른 영역에 올라가게 되고 
// 한 번만 변경해도 모든 마린의 공격력이 바뀌게 되는 것이다.

class Player
{
public:
    int _id;
};

// 정적 전역 객체
static int G_id = 1;

int Generateid()
{
    // 생명주기 : 프로그램 시작/종료(메모리에 항상 올라가 있음)
    // 가시범위(사용할수 있는 범위) : 생성된 위치에 따라 다름

    // 정적 지역 객체
    static int s_id = 1;
    // 그냥 int s_id = 1; 이었다면 Generateid가 호출 될때마다 1로 초기화가 되겠지만, static을 붙이는 순간 값이 1로 계속 유지되어서 
    // 초기화는 맨처음에 이 함수가 첫번째로 호출 되었을때 딱 한번만 해주게 될거고
    // 그다음부터는 초기화를 안하고 그냥 그값을 이용해서 s_id++ 이 코드대로 1씩 증가 할것이다

    return s_id++;

    // 만약, 일반 함수 내에 정적 변수를 생성하였다면, 스택에 올라가는 것잍 아니라 데이터 영역에 올라간다 
    // 프로그램 시작과 동시에 메모리에 올라가게 되지만 해당 함수 내에서만 사용이 가능하다는 특징이 있다.
    // 정적 함수도 같은 특징을 가지게 된다. 단, 정적 함수 내에 사용되는 변수는 정적 변수만 가능하다.
}


class Marine
{
public:
    void TakeDamage(int damage)
    {
        _hp -= damage;
    }

    static void SetAttack()
    {
        // static이 붙는 순간 Marine이 있건 없건 전혀 상관 없이 얘는 사실상 이렇게 밖에 빼서 전역 함수로 만들어준것 마냥 
        // 독립적으로 동작을 하게 된다

        // 사실상 스태틱 안에서는 이런 스태틱 변수들을 건드리는 것은 아무런 상관이 없지만, _hp = 100 이렇게 종속적인 일반 멤버 변수들을
        // 고친다거나 아니면 TakeDamage같은 어떤 특정 객체랑 연관성이 있는 애를 호출하거나 하는 부분도 못하게 된다

        // Marine이라는 설계도 상으로만 마린 안에 있는 일종의 전역 함수라고 보면된다

        // TakeDamage(10); // 안됨
        // _hp = 100;   // 안 됨
        s_attack = 10;

    }

public:
    // 특정 마린 객체에 종속적(일반 멤버 변수)
    int _hp;

    // 특정 마린 객체와 무관
    // 마린이라는 클래스 자체와 연관
    // 즉, static이 붙으면 s_attack의 이름을 가진 변수의 값을 변경했다고 할때, 똑같은 이름을 가진 모든 변수에 찾아갈 필요없이
    // 모든 애들한테 공통적인 정보가 수정이 된다
    static int s_attack; // 설계도상으로만 존재
};

int Marine::s_attack = 0;
// 전역으로 외부선언

class TestClass
{
    int _a;
    int _b;
};

int main()
{
    TestStruct ts;
    ts._a = 1;

    TestClass tc;
    //tc._a = 1; // error


    Marine m1;
    m1._hp = 40;

    Marine::s_attack = 6;
    //m1.s_attack = 6;

    Marine m2;
    m2._hp = 40;
    //m2.s_attack = 6;

    // 마린 공격력 업그레이드 완료! (Academy에서 업그레이드 끝!)
    Marine::s_attack = 7;
    Marine::SetAttack();

    return 0;

}