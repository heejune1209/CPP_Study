#include <iostream>
using namespace std;

// 상속성

// 객체 지향(object oriented programming)
// 상속성
// 은닉성
// 다형성

// 다형성 (Poly + morphism) = 겉은 똑같은데, 기능이 다르게 동작한다.
// - 오버로딩(Overloading) = 함수 중복 정의 = 함수 이름의 재사용
// = 오버라이딩(Overriding) = 재정의 = 부모클래스의 함수를 자식 클래스에서 재정의

// 바인딩(Binding) = 묶는다
// 프로그램에 사용된 구성 요소(각종 값들)가 확정되어 더 이상 변경할 수 없는 상태가 되는 것을 의미한다
// - 정적 바인딩(Static binding): 컴파일 시점에 결정되어 값이 묶여지는 것을 의미한다

// 보통 일반적인 전역변수나 값이 바뀌지 않을 각종 값들이 정적 바인딩된다.
// - 동적 바인딩(Dynamic Binding) : 실행 시점에 결정되어 값이 묶여지는 것을 의미한다. 
// 참고로 동적 바인딩은 면접 단골 질문(주의 깊게 공부)
// 일반 함수를 부모 클래스 타입으로 넓게 잡아 사용하면 자식 클래스까지 사용할 수 있다는 장점이 있지만 정적 바인딩으로 인해 어떤 클래스인지까지는 알지 못한다.
// 그러한 점을 보완하기 위해 동적 바인딩으로 변경해주어야한다.

// 일반 함수는 정적 바인딩을 사용
// 동적 바인딩을 원한다면? -> 가상 함수(Virtual function)

// 그런데 실제 객체가 어떤 타입인지 어떻게 알고 알아서 가상함수를 호출해 준걸까?
// - 가상 함수 테이블 (Vftable)

// .Vftable [] 4바이트(32) 8바이트(64)

// [vMove] [vDie]

// 결국에는 이 코드 자체만 놓고 보면 사실 알 수 없지만 실질적으로 이 객체의 첫 메모리에 내가 호출해야 되는 함수의 
// 일종의 표지판을 들고 있다는 셈이 되는 거죠 어찌 됐건 우여곡절 끝에 그렇게 해가지고 온갖 똑같은 플레이어 포인터라고 하더라도 걔가
// 원본이 나이트였는지 아니면 메이지였는지 무엇으로 만들어져 있었는지 따라가지고 알아서 찾아가지고 
// 그 원본 객체에 해당하는 버전의 가상함수를 이렇게 호출을 해줄 수 있다는 얘기가 되겠습니다

// 순수 가상 함수 : 구현은 없고 '인터페이스'만 전달하는 용도로 사용하고 싶을 경우 사용한다 
// 추상 클래스 : 순수가상함수가 1개 이상 포함되면 바로 추상 클래스로 간주
// - 직접적으로 해당 클래스를 이용해서 객체를 만들수 없게된다
// - 순수가상함수를 상속받아서 구현부를 재정의 해서 사용할수 있다.

class Player
{
public:

	Player()
	{
		_hp = 100;
	}
	void Move() { cout << "Move Player!" << endl; }

	// void Move(int a) { cout << "Move Player (int) !" << endl; } -> 오버 로딩
	void vMove() { cout << "vMove Player!" << endl; }
	virtual void vDie() { cout << "vDie Player!" << endl; }

	// 순수가상함수
	virtual void vAttack() = 0;
	// 구현부는 들어가지 않고 반드시 플레이어라는 애를 상속하는 애가 직접적으로 vAttack이라는 함수를 구현해서 사용해라라는 의미
	// 무조건 재정의를 해야한다

public:
	int _hp;
};

class Knight : public Player
{
public:

	Knight()
	{
		_stamina = 100;
	}
	void Move() { cout << "Move Knight!" << endl; }

	// 가상함수는 재정의를 하더라도 가상함수다!
	void vMove() { cout << "vMove Knight!" << endl; }
	virtual void vDie() { cout << "vDie Knight!" << endl; }
	// 원래는 Move Player!이렇게 출력되었지만, 이렇게 가상함수 코드를 작성해놓고 빌드를 하면 vMove Knight!, vDie Knight! 이렇게 출력된다.
	// 그러니까 즉, virtual의 역할은 기본 클래스에서 virtual을 사용해서 정의하면 나중에 자식(하위, 파생) 클래스에서 똑같은 함수를 재정의 했다고 할때, 
	// 그 자식클래스에서 재정의 한것을 사용한다.(override된다)
	// 원래는 virtual이 없었다면 main함수에서 MovePlayer(&k);이렇게 썼을때 기본 클래스에 작성했던 함수를 사용한다. 
	// 그래서 Move Player! 이렇게 출력되었던 것이다.
	// 약간 일단 틀을 만들어놓고 나중에 똑같은 이름의 함수를 사용할때 그 함수를 찾아가서 수정할 필요없이 
	// 바로 파생클래스의 함수에서 적용하고 싶을때 사용할듯 
	// 즉, 가상 함수는 기본클래스 내에서 선언되어 하위클래스, 파생클래스에서 
	// 멤버함수 virtual 키워드를 붙여 그대로 사용을 하거나 재정의해서 사용하는 멤버 함수입니다.
	// 그리고 부모클래스에서 똑같은 함수에 virtual을 써 놓기만해도 자식클래스에 void vMove() { cout << "vMove Knight!" << endl; }
	// 이렇게 사용해도 "vMove Knight!"가 출력된다

	virtual void vAttack()
	{
		cout << "vAttack Knight!" << endl;
		// 이렇게 상속받은 클래스에서 구현부를 만들어야 나이트를 객체로 사용할수 있다
	}

public:
	int _stamina;
};

class Mage : public Player
{
public:


public:
	int _mp;
};

// [[player]]
// [ Knight ]
// 메모리 주소가 아래쪽으로 증가한다고 하면 이런 그림이 된다
// 부모 클래스의 포인터를 받는 전역 함수
void MovePlayer(Player* player)
{
	//Knight* k = (Knight*)player; // 나이트로 뭔가를 바꿔가지고 이렇게 사용할 수는 없을까?
	//k->_stamina = 100;
	// 나이트로 다시 바꿔주세요 라고 한 다음에 요렇게 해가지고 뭐 자연스럽게 스테미나도 고치고
	// 하는 식으로 만약에 고치면 안 될까 싶기는 합니다
	// 그런데 만약에 진짜 진짜 원본이 나이트였다고 하면은 사실 요렇게 다시 원래대로 바꾸는 것도 상관이 없기는 한데 경우에 따라 가지고 
	// 만약에 원본이 플레이어였다고 하면은 요런 느낌 그런데 우리가 다시 얘를 나이트형 포인터로 변환했다는 것은 우리는 이 상태로
	// 일단은 다시 인식을 하겠다는 건데 이러면 조금 문제가 발생할 수 있는 게 애당초 원본은
	// 플레이어였는데 우리는 얘를 나이트라고 가정을 하고 건드린다는 얘기는 여기 있는 메모리를 침범해 가지고 
	// 엉뚱한 메모리를 지금 우리가 건드리고 있는 겁니다 그러니까 플레이어에서 나이트로 넘어가는것은 쉽게될수가 없다는 얘기이다
	// 정말로 우리가 나이트를 넘겨줬는지를 다른 문법을 이용해서 체크를 하고 넘어갔다면 일반적인 상황에선 이게항상 맞다는 보장이 없으니까
	// 절대로 이렇게 해선 안된다
	// 원본객체에 따라서 다르게 다르게 동작해야되는 경우는 가상함수를 이용해야한다

	// 그래가지고 뭐 실제 예에서 RPG에서도 가상함수로 돌릴 그런 기능은 굉장히 많죠
	// 이동하는 것 뿐만 아니라 공격하는 기능, HP를 깎는 기능 등등 모든 그런 플레이어나 몬스터 등을 합쳐가지고 통합해서 
	// 관리를 하고 싶다고 하면은 그런 거를 다 대부분 있는 기능들을 이렇게 가상함수로 만들어줘가지고 관리를 하면 쉽게 동작을 하게된다는 얘기이다

	player->vMove(); // virtual 안써서 부모클래스에 있는 것을 출력
	player->vDie();   // virtual 써서 자식클래스에 있는 것을 출력
	// 디버깅을 해본 결과, 플레이어 객체의 첫 번째 오프셋 주소에는 00569b54 이라는 가상의 주소가 있는 걸 볼 수가 있는데
	// 요게 바로 Virtual Function의 테이블 주소라는 걸 알 수가 있습니다
}

// 분명히 아까 이 MovePlayer를 만들 때는 이 player에 대한 정보밖에 모르지, 넘겨준 포인터 즉 주소 바구니에는 주소가 있는데 그 주소를 타고 가면 
// player가 있다는 정보를 여기서 우리가 받았지만 그거 이상의 정보는 우리가 알 수 없다고 했습니다
// 어떤 원리를 이용해서 실제 원본 함수를 찾아가는 것인가?

void MoveKnight(Knight* knight)
{
	knight->Move();
}



int main()
{
	//Player p; // => Player클래스에 순수 가상함수를 만들어줘서 추상클래스로 변했다. 그래서 Player를 가지고 객체를 만들어서 독단적으로 사용할수 없음
	// 무조건 간접적으로 Knight k;이렇게 나이트를 만들어서 나이트를 넘겨주는 방식으로는 사용할수있지만 플레이어 자체를 독단적으로 사용불가
	// MovePlayer(&p); // 플레이어는 플레이어다? Yes
	// MoveKnight(&p); // 이렇게하면 에러가 나는것을 알수 있다. -> 플레이어는 기사다? NO
	// 이렇게 player가 상위 클래스이고 knight가 파생된 자식클래스라고 한다면 어찌됐건 자식클래스에서 부모클래스쪽으로 넘어가는것은 되지만
	// 부모 클래스에서 자식 클래스로 넘어가는것은 자연스럽게 되지 않는다. 논리적으로 맞지 않음


	Knight k;
	// MoveKnight(&k); // 기사는 기사다? yes
	MovePlayer(&k);
	// 정적 바인딩으로 인해 나이트의 주소값을 넘겨줬는데 부모 클래스의 함수 출력
	// 기사는 플레이어다? yes => 빌드 하면 Move Player! 이렇게 출력된다
		// 이것은 논리적으로 맞아서 에러가 나지않는다

		// 즉, 말하고자 하는것은 공통적으로 이 MovePlayer 함수를 그냥 사용할 수 있다는 엄청난 장점이 생기게 되고
		// 실제로 나중에 게임을 만들 때도 모든 플레이어들을 다 뭉뚱 그려가지고 이렇게 하나의 함수로 관리를 하게 될겁니다
		// 그리고 더 나아가서는 플레이어랑 몬스터도 예를 들면 크리쳐라는 거로 묶어가지고 전투 시스템을 구현할 때 
		// 인자로 크리쳐형 포인터를 받게 한다거나 이런 식으로 그게 몬스터건 플레이어건 관계없이 
		// 똑같은 룰을 적용해가지고 함수를 한방에 실행시킬 수 있도록 기능을 이렇게 묶어가지고 관리를 할 수 있다는 
		// 엄청난 장점이 생긴다는 얘기가 되겠습니다

		// knight클래스에서 재정의한 함수 출력
		//k.Move(); // => "Move Knight!" 출력

	return 0;

	// 결론 : 오버라이드는 정확히는 부모 클래스 함수를 자식클래스에서 재정의 해서 사용한다는 것임.
	// 일반적으로 부모 클래스에서 똑같은 함수를 자식클래스에서 똑같은 이름, 완전히 똑같은 모양으로 재정의 하게되면 자식클래스의 함수가 덮어서 
	// 자신만의 함수를 갖게되었다는 얘기가 된다.
	// 물론 그렇다 해서 부모 클래스의 똑같은 함수를 사용하지 못하는것은 아니다.
	// 다만 가상함수가 아닌 그냥 일반 함수로 만들어 줄 경우엔 굉장히 아쉬운것중에 하나가 void MovePlayer(Player* player) 
	// 이렇게 포인터로 그냥 통합해 가지고 우리가 관리를 할 경우 일반 함수를 호출하게될경우엔 Player* 이 타입에 해당하는 그 함수가 호출이 되게 된다
	// 즉 부모 클래스의 void Move() { cout << "Move Player!" << endl; } 이런 똑같은 함수가 호출된다.
	// 하지만 부모클래스에 똑같은 함수를 virtual을 사용하고, 자식클래스에서 똑같은 함수를 가지고 재정의했다고 하면
	// 그러면 자식 클래스에서 재정의한것을 출력하게 된다. (예시) "vMove Knight!" )
}