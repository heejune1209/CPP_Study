#include <iostream>

using namespace std;
// 주석 팁
// 드래그후 ctrl+k+c 여러줄을 한번에 주석처리, ctrl+K+u : 주석해제

// 1장 정수
// 변수 선언 방법
// [타입] [이름];
// [타입] [이름] = [초기값];

// 0이 아닌 초기화 값이 있으면 .data 영역.
int hp = 100;
// 정수 타입들
char a; // 1바이트 (-128 ~ 127가 허용 범위이다.)
short b;  // 2바이트(-32768~ 32767)
int c;  // 4바이트 (-21.4억~ 21.4억)
__int64 d; // 8바이트 (long long)(ㅈㄴ 큼)

unsigned char ua; // 1바이트 (0 ~ 255가 허용 범위이다.)
unsigned short ub;  // 2바이트(0 ~65536)
unsigned int uc;  // 4바이트 (0 ~ 42.9억)
unsigned __int64 ud; // 8바이트 (long long)(0 ~ ㅈㄴ 큼)

// 참고) 이론적으로 양수만 존재할 수 있는 데이터 unsigned
// 무조건 unsigned를 사용할지 의견이 갈림.
// - 레벨이 음수라는 것은 말이 안된다. -> 그럼 차라리 프로그램을 크래시 내서 버그를 빨리 찾는게 낫다.
// - unsigned / signed 사이의 변환


// unsigned는 최상위 비트를 음수가 아니라 양수로 보겠다는 의미이다. char로 예를 들면 허용 범위가 -128~ 127인데 unsigned가 붙으면
// 허용 범위가 0~255이 된다. 
// signed char a; 이것처럼 정수 타입 앞에 signed가 붙어있으면 부호가 있다는 뜻이고 부호가 있다는 것은 최상위 비트는 음수의 값으로 
// 사용하겠다는 의미이다. 그래서 평소에는 int a; int 앞엔 signed가 생략되어있다.

// 귀찮은데 그냥 대충 4바이트로 가면 안될까?
// => 콘솔/온라인 게임 -> 메모리가 늘 부족.
// -> 온라인 게임 -> 4바이트 * 1만명 
// 초기값이 0이거나, 초기값이 없는 변수라면 .bss영역.
int main()
{
    b = 0;
    b = b + 1;
    cout << b << endl; // 결과: -32768
    // 이렇게 범위를 초과해서 일어나는 버그를 정수 오버플로우 라고 한다.
    ub = 32767;
    ub = ub - 1; // 결과 : 32766
    cout << ub << endl;
    // 거꾸로 너무 적어서 일어나는 버그를 정수 언더 플로우라고 한다.

    cout << "체력이 " << hp << "남았습니다. " << endl;
}