#include <iostream>
using namespace std;

// 타입 변환

// malloc -> void*로 반환하고, 이를 우리가 (타입 변환)을 통해 사용했었음

class Knight
{
public:
	int _hp = 10;
};

class Dog
{
public:
	Dog()
	{

	}
	// 타입 변환 생성자
	Dog(const Knight& knight)
	{
		_age = knight._hp;
	}
	// 타입 변환 연산자
	operator Knight()
	{
		/*Knight knight;
		knight._hp = _age + _cuteness;
		return knight;*/

		// 나 자신을 나이트로 변환해서 반환
		return (Knight)(*this);

		// 타입 변환 연산자는 다른 연산자 함수와는 다르게 반환타입을 입력하지 않는다. 
		// 함수의 이름 자체가 모든 의미를 내포하고 있기 때문이다.

	}

public:
	int _age = 1;
	int _cuteness = 2;
};

class BullDog : public Dog
{
public:
	bool _french; // 프렌치 불독
};


int main()
{
	// 타입 변환 유형 (비트열 재구성 여부)

	// [1] 값 타입 변환
	// 특징) 의미를 유지하기 위해서, 원본 객체와 다른 비트열 재구성
	{
		int a = 123456789;
		float b = (float)a;


		// a는 2의 보수로 표현되지만 b는 부동소수점(지수 + 유효숫자) 방식으로 표현된다. 원본값의 근사치로 변환하여 담는다.

		cout << b << endl;
	}

	{
		// [2] 참조 타입 변환
		// 특징) 비트열을 재구성 하지않고, 관점만 바꾸는것 (값 타입 변환과 달리 의미를 포기하고 데이터만 유지하는 셈)
		// 데이터 자체는 똑같이 유지를 하고 있지만 데이터를 바라보는 관점이 변해서 엉뚱한 의미를 갖게됨
		// 거의 쓸일이 없지만, 포인터 타입 변환도 '참조 타입 변환' 동일한 룰을 따르니까 일석이조로 공부하자
		int a = 123456789;
		float b = (float&)a;
		cout << b << endl;
	}

	{
		// 안전도 분류

		// [1] 안전한 변환
		// 특징) 의미가 항상 100% 완전히 일치하는 경우
		// 같은 타입이면서 크기만 더 큰 바구니로 이동
		// 작은 바구니 -> 큰 바구니로 이동 OK (업 캐스팅)
		// ex) char 👉 short, short 👉 int, int 👉 __int64 등

		int a = 123456789;
		__int64 b = a;
		cout << b << endl;
	}

	// [2] 불안전한 변환
	// 특징) 의미가 항상 100% 일치한다고 보장하지 못하는 경우를 뜻한다. 
	// 타입이 다르거나 같은 타입이지만 큰 바구니에서 작은 바구니로 이동(다운캐스팅)하는 것을 말한다.
	{
		int a = 123456789;
		float b = a;
		short c = a;
		cout << b << endl;
		cout << c << endl;
		// 이러한 과정에서 데이터가 손실될 가능성이 크다
	}

	// 프로그래머 의도에 따른 분류
	// [1] 암시적 변환
	// 특징) 이미 알려진 타입 변환 규칙에 따라서 컴파일러가 자동으로 변환해주는 것을 의미한다.
	{
		int a = 123456789;
		float b = a;  // 암시적으로
		cout << b << endl;
	}

	// [2] 명시적 변환
	// 특징) 직접적으로 변환할 타입을 지정해주는 것을 의미한다.
	{
		int a = 123456789;
		int* b = (int*)a; // 명시적으로 해줘야함 왜냐? int형을 포인터형으로 바꾸는것이기 때문
		cout << b << endl;
		// b엔 16진수로 나타내어진 123456789이 들어가있음
	}

	// 아무런 연관 관계가 없는 클래스 사이의 변환

	// [1] 연관없는 클래스 사이의 '값 타입' 변환
	// 특징) 일반적으로 안됨 (예외 : 타입 변환 생성자나 타입 변환 연산자를 이용해 변환할 수 있다. )
	{
		// 타입 변환 생성자가 있어서 가능. 없으면 변환이 불가능하다.

		// 타입 변환 생성자를 이용해 변환가능해짐
		Knight knight;
		Dog dog = (Dog)knight;

		// 타입 변환 연산자를 이용해 변환가능해짐
		Knight knight2 = dog;


	}

	// [2] 연관없는 클래스 사이의 '참조 타입' 변환

	{
		Knight knight;
		// 어셈블리  : 포인터 = 참조

		// Dog& dog = (Dog&)knight; 왜 통과가 될까?
		// [ 주소 ] => [ Dog ]
		//  void* 포인터 처럼 실질적으로 어떤 데이터가 있는지 아직 정해지지도 않은거고 우리가 어떻게 이제 이걸
		// 변환해서 어떻게 사용할지 잘 결정해서 사용해야하는 경우가 비일비재 생기기 때문에
		// 이 주소를 타고 가면 ~~이 있어요 라는 문법 자체는 얘가 실질적으로 진짜인지 아닌지는 
		// 일단은 여기서 체크를 하는 게 아니라 일단 통과를 시켜 준다는 얘기가 된다

		Dog& dog = (Dog&)knight;
		dog._cuteness = 12;

		// 암시적으로는 불가능하나 명시적으로 이렇게 dog에 참조로 바꿔 주라고 하면 통과가 되는것을 볼수 있다
		// 하지만 knight인데 dog의 참조로 바꿔주면 엉뚱하게 메모리를 초과해서 사용하게 되는 문제가 일어난다
		// 왜냐면 이 나이트라는 변수 자체는 자 이 나이트라는 걸 우리가 만들 때 보면은 얘는 int 하나만 넣어줬고
		// dog라는 것은 8(int 두개)바이트 짜리로 만들어줬기 때문에 dog의 cuteness를 건들게 되면 건들이면 안되는 
		// 메모리를 건들게 된다
	}

	// 상속 관계에 있는 클래스 사이의 변환

	// [1] 상속 관계 클래스의 값 타입 변환
	// 자식 👉 부모는 가능하지만 부모 👉 자식은 불가능하다.
	{
		// 부모 👉 자식은 불가능
		//Dog dog;
		//BullDog bulldog = (BullDog)dog;

		// 자식 👉 부모는 가능
		BullDog bulldog; // error
		// 왜 에러가 났냐면 생성자에 관련된 문제이다.
		// 우리가 dog라는 것을 만들면서 타입 변환 생성자, 즉 생성자를 기본생성자가 아닌 다른 버전으로 하나를 만들어
		// 주는 순간 기본생성자는 막히기 때문에 이런 문제가 발생했다 
		// 그러니까 타입변환 생성자를 아예 없애주거나 아니면 기본 생성자를 이렇게 따로 추가를 해주면 해결이 된다

		Dog dog = bulldog;
		// 불독에서 개로 넘어가려고 했으면 얘는 일부 데이터가 쭉 딸린 채로 나머지 필요한 데이터만 적절히 넣어 줘 가지고 
		// 이렇게 변환이 될 수 있었다
	}
	// [2] 상속 관계 클래스의 참조 타입 변환
	// 자식 👉 부모는 가능하지만 부모 👉 자식은 암시적으로는 불가능하나 명시적으로는 가능하다.
	{
		// 부모 👉 자식
		Dog dog;
		BullDog& bulldog = (BullDog&)dog; // 가능
		// BullDog& bulldog = dog;  // 불가능
		// 근데 이렇게 BullDog& bulldog = (BullDog&)dog; 명시적으로 변환을 하면
		// 연관없는 클래스 사이의 '참조 타입' 변환처럼 메모리 구조 상으로는 도그가 훨씬 더 작은데 
		// 얘를 더 큰 그런 불독 타입으로 바꿔주겠다는 것은 만약에 이게 통과가 된다고 하면 
		// BullDog의 _cuteness으로 접근해가지고 값을 써주면 엉뚱한 메모리를 건드리게 되는 무서운 일이 일어난다

		// 자식 👉 부모
		//BullDog bulldog;
		//Dog& dog = bulldog;
	}

	// 결론: 
	// 값 타입 변환 : 비트열도 변경하고, 논리적으로 말이 되게 바꾸는 변환
	// 논리적으로 말이 된다 ? (ex.BullDog->Dog) 👉 OK
	// 논리적으로 말이 안 된다 ? (ex.Dog->BullDog, Dog->Knight) 👉 NO
	// 참조 타입 변환 : 비트열은 놔두고 우리의 관점만 바꾸는 변환
	// 명시적 요구를 하면 변환이 가능하다.
	// 암시적으로 그냥 해주는지는 안전성 여부와 관련 있다.
	// 안전하면 암시적으로도 OK
	// 메모리 침범 위험이 있는 경우는 암시적으로 해주진 않는다.
	// 대신에 명시적으로 정말 변환하겠다고 최종 서명을 하면 가능하다.

	return 0;

}