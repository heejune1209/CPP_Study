#include <iostream>
using namespace std;

// 얕은 복사 vs 깊은 복사
// 메모리에 관한 부분은 죄다 중요!
// 면접에도 단골질문
class Pet
{
public:
    Pet()
    {
        cout << "Pet()" << endl;
    }

    ~Pet()
    {
        cout << "~Pet()" << endl;
    }

    Pet(const Pet& pet) // 복사 생성자
    {
        cout << "Pet(const Pet& pet)" << endl;
    }

    Pet& operator=(const Pet& pet)
    {
        cout << "Pet& operator=(const Pet& pet)" << endl;
        return *this;
    }
};

class player
{
public:
    player()
    {
        cout << "player()" << endl;
    }

    // 복사 생성자
    player(const player& player)
    {
        cout << "player(const player& player)" << endl;
    }
    // 암시적 복사 생성자 스탭
// 우리가 나이트에 명시적으로 어떠한 형태의 복사 시리즈도 만들어 준 적이 없는데, Knight knight2 = knight; 이 코드를 실행하니까
// 부모 클래스의 복사 생성자가 호출이 되고 그 다음에 멤버 클래스 즉 펫에 대한 복사 생성자도 호출이 된다
// player(const player& player), Pet(const Pet& pet) 이렇게 두개가 호출됨

    // 복사 대입 연산자
    player& operator=(const player& player)
    {
        cout << "player& operator=(const player& player)" << endl;
        return (*this);
    }

public:
    int _level = 0;

};

class Knight : public player
{
public:
    Knight()
    {
        //_pet = new Pet();
    }

    // 복사 생성자
    Knight(const Knight& knight) : player(knight), _pet(knight._pet)
    {
        cout << "Knight(const Knight&)" << endl;
        _hp = knight._hp;
        //_pet = new Pet(*(knight._pet)); // 깊은 복사
        // pet은 참조값을 받고 있고 _pet은 포인터이기 때문에 *를 붙여준다
    }
    // 이렇게 나이트에 복사 생성자를 명시적으로 Knight(const Knight& knight) 이렇게 만들어 준다고 하면 까먹지 말아야 할게 될 게 
// 결국에는 이 부모님과 관련된 부분들도 적절히 복사가 되어가지고 챙겨줘야 되는데
/*
Knight(const Knight& knight)
{
    cout << "Knight(const Knight&)" << endl;
    _hp = knight._hp;

}
*/ // 그냥 이렇게만 만들어주면 부모 클래스 부분이 챙겨지지가 않는다는 어마어마한 차이가 있습니다
// 그래서 실행 해보면 이제는 아까와 마찬가지로 플레이어랑 펫에 대한 복사와 관련된 부분들이 실행이 되는 게 아니라 
// 그냥 기본 상태로 그냥 기본 펫, 기본 플레이어 (player(), Pet()) 이 만들어진다

// 그래서 부모 클래스의 복사 생성자가 호출이 되고 그 다음에 멤버 클래스 즉 펫에 대한 복사 생성자도 호출이 되고 싶으면, 나이트의 복사 생성자 옆에
// Knight(const Knight& knight) : player(knight), _pet(knight._pet) 이렇게 써줘야지만, 호출이 된다

    // 복사 대입 연산자
    Knight& operator=(const Knight& knight)
    {
        cout << "operator=(const Knight& knight)" << endl;

        player::operator=(knight);
        _pet = knight._pet;

        _hp = knight._hp;
        //_pet = new Pet(*(knight._pet)); // 깊은 복사
        return *this;
    }
    // 명시적으로 복사 대입 연산자를 만들어 주게되면 복사 생성자에서 경험 했던것 처럼 컴파일러가 직접적으로 챙겨 주지 않는다.
// 그래서 복사 생성자에서 Knight(const Knight& knight) : player(knight), _pet(knight._pet) 이렇게 직접 챙겼던 것처럼 
// 복사 대입 연산자에서도 
// player::operator=(knight);
// _pet = knight._pet;
// _hp = knight._hp;
// 이런식으로 직접 우리가 챙겨야 한다

    ~Knight()
    {
        //delete _pet;
        // 이렇게 Knight(), ~Knight() 생성자와 소멸자를 만들어주면 나이트와 펫의 생명주기가 완전히 똑같아짐
        // 서로 달라지는 것이 아니고 나이트가 만들어 질때 펫도 간접적으로 같이 생성이 되고
        // 나이트가 소멸이 될때 펫에 있는 메모리도 같이 날려주는 개념이다
        // 근데 이렇게 만들어 주면 아까 만들어준 얕은 복사가 완전히 큰 문제로 작동
    }
public:
    int _hp = 100;
    Pet _pet; //(멤버 클래스) // 이렇게 포인터로 들고 있지 않고 펫 자체를 이렇게 들고 있게 되면은 여러가지 단점들이 생기게 된다
    // 쉽게 말해서 나이트란 애가 만들어 지자마자 펫이란 애도 같이 만들어 지게 되는거고 나이트가 소멸이 되자마자 이 펫도 같이 소멸되게 된다는 문제
    // 가 생김. 말그대로 나이트와 펫이 일치가 된다는 얘기.
    // 생명주기 관리가 어려워짐
    // 근데 더큰 문제는 뭐냐면 만약에 펫에 있는 데이터가 4000바이트의 데이터가 여기 들어가 있다고 하면 그 내용이 그대로 나이트에 똑같이 들어가다
    // 보니까 이 나이트도 덩달아서 굉장히 비대해진다는 문제가 될수있다

    // 근데 그거와 별개로 더 큰 문제는 예를 들어서 펫은 펫인데 토끼라는 펫을 이렇게 상속받아서 만들수도 있을거고 다양한 방식으로 펫을 상속받아서
    // 만들어주고 싶다고 한다면은 만약에 그 상태로 나이트에 펫 자체가 들어가 있다고 하면 래빗 펫을 사용할수 없게 된다
    // 굳이 래빗 펫을 사용하고 싶다고 한다면 Rabbit _pet; 이렇게 바꿔치기는 해줄수 있지만 다른 펫들이 다양하게 있다고 했을때 
    // 거북이 펫이 있다고 하면 Rabbit _pet; 이 코드때문에 넣어줄수 없는 문제가 생긴다 코드를 깔끔하게 그래서 이렇게 어떤 클래스에서 
    // 다른 클래스를 들고 있을때는 일반적으로 이렇게 그자체를 들고 있기 보단, 포인터를 들고 있는 혹은 참조값을 들고 있는 형태로 만들어주는것이
    // 더 깔끔하다
    //Pet* _pet; 
};

int main()
{
    //Pet* pet = new Pet(); // 펫을 힙영역에다 생성

    Knight knight; // 기본 생성자
    knight._hp = 200;
    knight._level = 99;
    //knight._pet = pet;
    // 여기서 펫을 knight에 복사를 해주어서 knight2, knight3에도 똑같은 펫을 공유할수 있게된다
    // 이런 형태의 복사를 얕은 복사라고 한다
    //cout << "---------------- 복사 생성자-------------" << endl;
    //Knight knight2 = knight;    // 복사 생성자
    // Knight knight3(knight);  // 같은 의미

    cout << "---------------- 복사 대입 연산자-------------" << endl;
    Knight knight3; // 기본 생성자
    knight3 = knight;   // 복사 대입 연산자 (오버로딩)

    // 위처럼 다양한 방법으로 복사를 할 수 있다. [복사 생성자]와 [복사 대입 연산자]는 우리가 클래스 내에 생성자를 따로 지정해 주지 않아도 
    // 컴파일러가 암시적으로 만들어주기 때문에 별다른 이상없이 복사를 할 수 있게된다. 
    // 일단은 컴파일러가 암시적으로 만들어 준 버전은 얘가 하려는 바는 뭐냐면은 그냥 메모리에 있는 데이터를 그대로 복사해 준다는 특징이 있습니다

        // 중간 결과) 컴파일러가 알아서 잘 만들어준다?
        // 하지만 따져야할게 있다

        // [얕은 복사 Shallow Copy]
        // 멤버 데이터를 비트열 단위로 '똑같이' 복사 (메모리 영역 값을 그대로 복사)
        // 포인터는 주소값 바구니 -> 주소값을 똑같이 복사 -> 동일한 객체를 가리키는 상태가됨.
        // 하지만 이렇게 한다면 총 3명의 기사가 힙 영역에 있는 하나의 펫을 같이 가리키게 되는 문제가 발생한다.

        // Stack : Knight [hp  0x1000] -> Heap 0x1000 Pet [   ]
        // Stack : Knight2 [hp  0x1000] 
        // Stack : Knight3 [hp  0x1000] 

        // [깊은 복사 Deep Copy]
        // 깊은 복사(Deep Copy)는 멤버 데이터가 참조(주소) 값이라면, 데이터를 새로 만들어 복사하는 방식을 의미한다. 
        // 원본 객체가 참조하는 대상까지 새로 만들어서 복사한다. 얕은 복사에서 발생하는 문제점을 해결하기 위한 복사 방식이다.
        // 완벽히 복사가 되는 개념
        // 포인터는 주소값 바구니 -> 새로운 객체를 생성 -> 상이한 객체를 가리키는 상태가됨.
        // Stack : Knight [hp  0x1000] -> Heap 0x1000 Pet [   ]
        // Stack : Knight2 [hp  0x2000] -> Heap 0x2000 Pet [   ]
        // Stack : Knight3 [hp  0x3000] -> Heap 0x3000 Pet [   ]

        // 이렇게 사용하게되면 기사 클래스의 복사가 이루어질 때마다 펫을 가리키는 주소도 새로 생성되어 기사 객체마다 따로따로 할당받게 되는 것이다. 
        // 클래스 내에 다른 클래스의 참조(주소)값을 담고 있을 땐 반드시 깊은 복사를 우선으로 생각해야한다.

        // 얕은 복사와 깊은 복사는 굉장히 중요한 개념이니까 이것에 대해선 꼭 숙지를 해주면 되겠다
        // 결국에는 포인터가 편하게 알아서 모든 일 처리를 해주던 암시적인 버전도 한계가 있다는 것을 기억.
        // 암시적으로 만들어준 버전을 그래도 사용한다고 하면 아까와 마찬가지로 이렇게 나이트를 복사해서 코드를 실행하다 보면 
        // 언제 어디선가 프로그램이 크래쉬가 날수 있다

        // 일반적으론 그렇긴 한데, 포인터가 등장했다고 해서 무조건 깊은 복사를 해야된다는 것은 아니라는 얘기가 된다

        // 실험)
        // - 암시적 복사 생성자 호출될 때 순서
        // 1) 부모 클래스의 복사 생성자 호출
        // 2) 멤버 클래스의 복사 생성자 호출
        // 3) 멤버가 기본 타입일 경우 메모리 복사 (얕은 복사 Shallow Copy)

        // - 명시적 복사 생성자 호출될 때 순서
        // 1) 부모 클래스의 기본 생성자 호출
        // 2) 멤버 클래스의 기본 생성자 호출

        // 암시적 복사 대입 연산자 Steps
        // 부모 클래스의 복사 대입 연산자 호출
        // 멤버 클래스의 복사 대입 연산자 호출
        // 멤버가 기본 타입일 경우 메모리 복사(얕은 복사 Shallow Copy)

        // 명시적 복사 대입 연산자 Steps
        // 알아서 해주는 게 없다.

        // 기본적으로 우리가 명시적으로 복사 생성자를 만들어 줬을때는 우리가 딱히 다른 것을 호출하라고 명시하지 않는 이상 부모 클래스와 멤버 클래스
        // 모두 기본 생성자가 호출이 된다는걸 꼭 기억을 해야한다

        // 왜 이렇게 호출될까?
        // 👉 객체를 복사 한다는 것은 두 객체의 값들을 일치시키려는 것이다. 따라서 기본적으로 얕은 복사(Shallow Copy) 방식으로 동작하게 된다.
        // 명시적 복사는 모든 책임을 프로그래머에게 위임하겠다는 의미를 가진다.
        // 👉 명시적으로 복사 생성자 혹은 복사 대입 연산자를 지정해주었을 때 연관된 다른 클래스들의 복사와 관련된 함수를 
        // 똑같이 명시적으로 설정해주지 않으면 일부만 복사되는 문제가 발생할 수 있다.
        // 명시적으로 복사를 하고 싶을 땐 모두 직접 관리해줘야 원하는 방식으로 복사를 진행할 수 있게 된다.

        return 0;
}