#include <iostream>
using namespace std;

// 동적 할당

// 메모리 구조 복습
// - 실행할 코드가 저장되는 영역 -> 코드 영역
// - 전역(global)/정적(static) 변수 -> 데이터 영역
// - 지역 변수/ 매개 변수 ->  스택 영역
// - 동적 할당 -> 힙 영역

// 지금까지 데이터 영역/ 스택 영역 이용해서
// 이런 저런 프로그램을 잘 만들어 왔다
// 굳이 새로운 영역이 필요할까?

// 실제 상황)
// - MMORPG 동접 1명 ~ 5만명, 몬스터 1마리 ~ 500만마리
// - 몬스터 생성 이벤트 -> 5분동안 몬스터가 10배 많이 나옴

// - 스택 영역
// 함수가 끝나면 같이 정리되는 불안정한 메모리
// 잠시 함수에 매개변수를 넘긴다거나 하는 용도로는 OK
// -메모리 영역
// 프로그램이 실행되는 도중에는 '무조건 사용되는'

// 희망사항)
// - 필요할때만 사용하고, 필요없으면 반납할수 있는!
// - 그러면서도 (스택과는 다르게) 우리가 생성/소멸 시점을 관리할 수 있는!
// - 그런 아름다운 메모리 없나? -> HEAP
// 동적 할당과 연관된 함수/ 연산자 : malloc/free, new / delete, new[] / delete[] => 매우중요

// malloc
// - 할당할 메모리 크기를 건네준다
// - 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다
// - 참고로 메모리가 부족하다 싶으면 nullptr를 반환한다.

// free
// - malloc (혹은 malloc과 비슷한 calloc, realloc 등의 사촌) 을 통해 할당된 영역을 해제
// - 힙 관리자가 할당/비할당 여부를 구분해서 관리


// new / delete
// - C++에서 추가됨
// malloc/free 함수인데, new / delete는 연산자(operator)
// malloc/free와 같은 기능으로 동작한다. new는 메모리 할당을, delete는 할당 받은 메모리를 해제한다.

// new[] / delete[]
// - new가 malloc에 비해 좋긴 한데, 배열과 같이 N개 데이터를 같이 할당하려면?

// malloc/free vs new / delete
// 사용 편의성 👉 new/delete 승!
// 타입에 상관없이 특정한 크기의 메모리 영역을 할당받으려면 ? 👉 malloc / free 승!
// 그런데 둘의 가장 근본적인 중요한 차이는 따로 있다.
// new / delete는(생성타입이 클래스일 경우) 생성자와 소멸자를 호출해준다.
// malloc/free로 했을땐 생성자가 호출이 되지 않는다

class Monster
{
public:
	Monster()
	{
		cout << "Monster()" << endl;
	}
	~Monster()
	{
		cout << "~Monster" << endl;
	}

public:
	int hp;
	int _x;
	int _y;
};


int main()
{
	//Monster monster[500 * 10000]; // Stack overflow , 스택 메모리를 초과해서 사용중
	// 애당초 스택은 이렇게 뭔가 어마어마하게 많은 데이터를 그렇게 저장하고 사용하는 용도로 만들어진게 아니라 함수들끼리 인자를 자연스럽게 
	// 전달하고 주고받는 용도로 만들어진 아이기 때문에 사실 이렇게 몬스터를 500만 마리씩 집어넣는것은 많이 이상함


	// 요즘 컴퓨터 프로그램은 기본적으로 커널영역과 유저영역이라는 영역이 두가지가 구분되어있음
	// 유저 영역 [메모장] [LOL] [곰플레이어] -> 이 구조는 모바일 기기에서도 똑같은 방식으로 동작을 한다
	// 유저 영역에서 실행되는 프로그램들은 완전히 서로 독립적으로 실행이 된다
	// 만약에 유저영역에 있는 프로그램이 추가적으로 동적할당이 필요해서 어떤 메모리를 추가적으로 사용을 해야 된다고 할때 메모리라는 것 자체는
	// [메모장] [LOL] [곰플레이어] 이런 애들이 각각 관리하는 개념이 아니라 커널 영역에 요청을 해서 허락을 받아가지고 받아 와야한다는 얘기가 된다
	// ------------------------
	// 커널 영역 (windows (운영체제)등의 핵심 코드)

	// 유저 영역) 운영 체제에서 제공하는 API를 호출. API는 그냥 함수라고 생각.
	// 커널 영역) 메모리 할당해서 건네줌
	// 유저 영역) 메모리 ㄳ

	// 유저 영역에서 메모리를 요청하면 커널영역에서 큼지막하게 메모리를 건네줌
	// 그리고 유저영역에 있는 세부적인 프로그램에서 1000바이트나 뭐 이렇게 특정 숫자가 필요하다고 하면 건네받은 메모리를 쪼개서 적당히 잘라서 씀.

	// C++에서는 기본적으로 CRT(C런타임 라이브러리)의 [힙 관리자]를 통해 힙영역 사용
	// 단, 정말 원한다면 우리가 직접 API를 통해 힙을 생성하고 관리할 수도 있음 (이런 경우는 MMORPG 서버라거나, 메모리 풀링)

	void* pointer = malloc(sizeof(Monster));
	// 1000바이트 만큼을 할당 받아서 시작주소를 포인터라는 애로 뱉어준다

	// void* __cdecl malloc(size_t _Size)
	// 메모리 할당 후 시작 주소를 가리키는 void형 포인터를 반환하고 인자로 할당 받을 메모리의 크기를 받는다.

	// 근데 void*는 뭘까?
	// *가 있으니까 포인터는 포인터 (주소를 담는 바구니) => OK
	// 타고 가면 void 아무것도 없다 ? -> No
	// 타고 가면 void 뭐가 있는지 모르겠으니까 너가 적당히 변환해서 사용해라 => OK

	Monster* m1 = (Monster*)pointer;
	m1->hp = 100;
	m1->_x = 1;
	m1->_y = 2;
	// m1의 시작 주소를 몬스터형 포인터로 바꿔주면 이제는 우리가 할당받은 메모리를 몬스터 용도로 활용하겠다 라는 의미가 되는 것이다
	// 몬스터는 m1이 Hp, x,y int형 3개를 갖고 있으니까 총 12바이트면 충분한데 1000바이트나 할당 받고 있다
	// 그래서 void* pointer = malloc(1000); => void* pointer = malloc(sizeof(Monster)); 이렇게 바꿔주면 메모리 낭비는 없앨수 있다

	// pointer를 잘 활용하다가 할당 받은 메모리 영역을 더이상 사용하지 않을 것이다 라고 하면 Free 라는 것을 호출.
	free(pointer);
	// void __cdecl free(void *_Block)

	// 동적 할당 버전에서는 필요할 때만 이렇게 사용하고 필요가 없어지면 다시 놔줄수 있다는 특징이 있다

	// 할당 해제할 메모리의 크기는 어떻게 알까?
	// 👉 malloc 등을 이용해 메모리를 할당받기 전, 할당 받을 메모리의 크기가 담긴 정보를 헤더에 저장해놓는다.
	// free를 이용해 할당 해제할 때 해당 데이터를 이용하여 해제하게 된다.

	// 발생 가능한 버그들
	// 1) Heap Overflow
	// 유효한 힙 범위를 초과해서 사용하는 문제
	// void* pointer = malloc(4);
	// Monster* m1 = (Monster*)pointer;
	// 할당받은것은 4바이트인데 Monster의 크기는 12바이트이다. 이때 힙 오버플로우 발생

	// 2) 메모리 누수
	// 메모리를 할당 후 해제하지 않으면, 즉 free를 하지 않으면 메모리 누수가 발생한다. 
	// 사용했던 메모리가 계속 쌓여 결국엔 힙 영역 전체를 차지하게된다.

	// 3) Double free
	// 메모리 할당 해제를 여러번 하는 것이다. 
	// 대부분 두 번째 할당 해제 시에 이미 유효하지 않은 값이 들어있는 걸 체크했기 때문에 크래시만 나고 끝난다.

	// 4) Use-After-Free
	// 가장 위험한 에러이다. 메모리를 할당 해제한 후에 다시 접근하여 사용하면 발생하는 문제이다. 
	// Double free와 다르게 바로 크래시가 나지 않고 다른 부분을 건드리게 되기 때문에 위험하다.

	// free를 해준 이후에도 포인터 자체가 없어진것은 아니기 때문에 주소를 우리가 포인터 변수에 계속 들고 있는 상태이다
	// 즉 이 주소를 계속 접근해서 사용할수 있는 상태라는 것이다
	/*m1->hp = 100;
	m1->_x = 1;
	m1->_y = 2;*/
	// 라고 다시 건드리게 되면 엉뚱한 메모리를 건드릴수 있다는 얘기가 된다
	// 근데 이 문제는 바로 크래시가 나지 않고 다른 중요한 값을 건드리게 되면 문제가 심각해진다
	// - 프로그래머 입장 : 망했다
	// - 해커 입장 : 심봤다!
	// 그럼 이런 문제를 방지하기위해서는 사용해서 날린 메모리는 free함과 동시에 더이상 사용하지 않을거니까 무조건 (널 체크)nullptr을 넣어준다
	//free(pointer);
	pointer = nullptr;
	m1 = nullptr;

	Monster* m2 = new Monster; // new 옆에는 어떤 타입을 넣어주게 되는데 꼭 얘가 클래스일 필요는 없다
	// 어떤 타입을 넣어주게 되면 그 타입의 크기만큼을 어떻게 보면 자동으로 할당해서 뱉어주는, 시작 주소를 뱉어주는 그런 개념이다
	// new / delete가 더 객체지향 스러움

	m2->hp = 200;
	m2->_x = 2;
	m2->_y = 3;
	delete m2;

	// malloc/free에서 말한 발생 가능한 버그들에 대해선 new/delete에서도 공통적으로 발생 가능함

	// 만약에 여러가지 몬스터를 동시에 만들고 싶다고 가정.
	// 배열.
	Monster* m3 = new Monster[5];
	// 시작 주소를 반환하는것은 똑같지만, Monster* m2 = new Monster 처럼 한마리만 만들어 주는것이 아니라, 다섯마리의 크기만큼을 일단 이어가지고
	// 할당을 해준다고 보면됨
	// 다섯마리에 해당하는 그 메모리 만큼을 쫙 이어서 잡아준다
	// 중요한것은 Monster* m3 = new Monster[5] 이렇게 new를 해줬다라고 하면 delete도 똑같이 delete[]를 해줘야 한다.
	// 즉 짝꿍을 잘 맞춰줘야함
	m3->hp = 200;
	m3->_x = 2;
	m3->_y = 3;


	// 이렇게 할당하면 m3의 크기는 60(12*5)이 된다

	// m3의 다음 주소에 할당
	Monster* m4 = (m3 + 1);
	m4->hp = 300;
	m4->_x = 4;
	m4->_y = 5;

	// 메모리 할당 해제
	delete[] m3;

	// 포인터이므로 1을 더해 다음 주소에도 값을 추가할 수 있지만 메모리 할당을 해제할 때는 똑같이 배열 표시를 붙여줘야하고
	// 위의 방식으로 m3를 할당 해제하면 m4의 값들도 모두 사라지게 된다.

	// new[] / delete[] 이 경우에선 생성자와 소멸자가 배열의 크기만큼 호출이 된다
	// ex) Monster* m3 = new Monster[5]; 의 경우 5번씩 호출됨

	return 0;
}